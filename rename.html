<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thumbnail Generator</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #EBEBEB;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        .main-container {
            display: flex;
            height: 100%;
        }
        .sidebar {
            width: 200px;
            padding: 0;
            border-right: 1px solid #444444;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative; /* Needed for the resizer */
        }

        #sidebar-resizer {
            position: absolute;
            top: 0;
            right: -5px; /* Positioned slightly outside the border */
            width: 10px;
            height: 100%;
            cursor: col-resize;
            z-index: 100;
        }
        .right-sidebar {
            width: 250px;
            padding: 0;
            border-left: 1px solid #444444;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
            background-color: #EBEBEB;
            color: black;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            border-bottom: 1px solid #444444;
            height: 36px;
            box-sizing: border-box;
            background-color: #1877f2;
            color: white;
            flex-shrink: 0;
        }

        .preview-header h3 {
            margin: 0;
            font-size: 16px;
        }

        #preview-container {
            flex-grow: 1;
            padding: 10px;
            position: relative;
            overflow-y: auto;
        }
        #right-sidebar-resizer {
            position: absolute;
            top: 0;
            left: -5px;
            width: 10px;
            height: 100%;
            cursor: col-resize;
            z-index: 100;
        }
        #sidebar-scroll-container {
            flex-grow: 1;
            overflow-y: auto;
            height: 0;
            text-align: left;
        }
        .sidebar-section h4, .sidebar-subcategory h5, #sidebar-scroll-container h4, #sidebar-scroll-container h5, #sidebar-scroll-container h6 {
            color: black;
            margin: 10px 0 5px 8px;
            cursor: pointer;
            user-select: none;
            padding: 2px 4px;
            text-align: left;
        }
        .sidebar-subcategory h5 {
            margin-left: 16px;
        }
        .sidebar-buttons {
            display: flex;
            height: 36px;
        }
        .sidebar-cog-btn {
            width: 100%;
            height: 36px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            box-sizing: border-box;
        }
        .sidebar-cog-btn:hover {
            background-color: #166fe5;
        }
        #load-directory-btn {
            flex: 1;
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 8px;
            cursor: pointer;
            box-sizing: border-box;
        }
        #load-directory-btn:hover {
            background-color: #166fe5;
        }
        .modal-content button, #last-dir-btn {
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 8px;
            cursor: pointer;
            box-sizing: border-box;
        }
        .modal-content button:hover {
            background-color: #166fe5;
        }
        #directory-picker {
            display: none;
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent the main content from causing page scroll */
        }
        .top-bar {
            padding: 10px 20px 10px 0px;
            border-bottom: 1px solid #444444;
            display: flex;
            align-items: center;
            height: 36px; /* Match button height */
            box-sizing: border-box;
            background-color: #1877f2;
        }
        .bottom-bar {
            padding: 10px 10px 10px 0px;
            border-top: 1px solid #444444;
            display: flex;
            align-items: center;
            height: 36px; /* Match button height */
            box-sizing: border-box;
            background-color: #1877f2;
            color: white;
            justify-content: space-between;
        }
        #bottom-bar-info {
            /* Styles removed to allow text to wrap */
        }
        .top-bar label {
            margin-right: 10px; /* Add padding between label and dropdown */
        }
        #thumbnail-container {
            flex-grow: 1;
            padding: 20px;
            position: relative;
            overflow: auto;
            min-width: 0;
        }
        #thumbnail-container.list-view-active {
            padding-top: 40px;
        }
        .thumbnail-wrapper.list-view {
            display: flex;
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
        }
        .thumbnail-wrapper.list-view .thumbnail {
            width: 128px;
            height: 72px;
            margin-right: 10px;
        }
        .thumbnail-wrapper.list-view {
            display: flex;
            align-items: center;
            width: 100%;
            margin-bottom: 2px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            padding: 5px;
            box-sizing: border-box;
        }
        .thumbnail-wrapper.list-view .thumbnail {
            width: 128px;
            height: 72px;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .thumbnail-wrapper.list-view .thumbnail-name {
            display: block;
            font-size: 14px;
            color: black;
            flex: 1 1 0px; /* Grow to fill space, start from 0 */
            min-width: 0; /* Absolutely necessary for flex-shrinking to work correctly */
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: none; /* Override the default max-width for list view */
        }
        .new-filename-placeholder, .canvas-name-placeholder {
            display: none;
        }
        .thumbnail-wrapper.list-view .new-filename-placeholder {
            display: block;
            font-size: 14px;
            color: #555;
            flex: 0 0 auto; /* Size to content, don't grow or shrink */
            text-align: left;
            margin-left: 15px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-style: italic;
            border-left: 1px solid #ccc;
            padding-left: 15px;
            min-height: 20px;
        }
        .thumbnail-wrapper.list-view .canvas-name-placeholder {
            display: block;
            font-size: 12px;
            color: #888;
            flex-shrink: 0;
            width: 100px;
            text-align: right;
            margin-left: 15px;
        }
        .thumbnail {
            object-fit: cover;
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            cursor: move;
        }
        .thumbnail-placeholder {
            background-color: #e0e0e0;
            border: 2px dashed #cccccc;
            border-radius: 6px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 2500; /* Increased z-index */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 24px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 680px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }
        .close {
            color: #606770;
            float: right;
            font-size: 32px;
            font-weight: bold;
            line-height: 1;
        }
        .close:hover,
        .close:focus {
            color: #1c1e21;
            text-decoration: none;
            cursor: pointer;
        }
        #batch-script {
            width: 100%;
            box-sizing: border-box;
            border-radius: 6px;
            border: 1px solid #ccd0d5;
            padding: 8px;
            font-family: "Courier New", Courier, monospace;
            margin-top: 8px;
            margin-bottom: 12px;
            resize: vertical;
        }
        #selection-box {
            position: absolute;
            border: 2px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.2);
            pointer-events: none;
            display: none;
            z-index: 2147483647;
        }
        #filename-builder-modal {
            z-index: 2500;
        }
        .landscape-row.selected-landscape {
            outline: 3px dashed blue;
        }
        .landscape-row.selected-landscape-rotate {
            outline: 3px dashed green;
        }
        .landscape-row.selected-delete {
            outline: 3px dashed purple;
        }
        .landscape-row.selected-edit {
            outline: 3px dashed #DAA520; /* Darker yellow */
        }
        .landscape-row.selected-shortcut {
            outline: 3px dashed orange;
        }
        .landscape-row.selected-play {
            outline: 3px solid cyan;
        }
        .thumbnail-wrapper {
            display: inline-block;
            vertical-align: top;
            text-align: center;
        }
        .thumbnail-name {
            font-size: 12px;
            color: black;
            background-color: #EBEBEB;
            padding: 2px;
            word-wrap: break-word;
            max-width: 256px; /* Match default thumbnail width */
            display: none; /* Hidden by default */
        }
        .thumbnail-wrapper.selected .thumbnail {
            box-shadow: 0 0 0 3px #007bff, 0 4px 8px rgba(0,0,0,0.4);
        }

        .thumbnail-wrapper.list-view.selected {
            background-color: #d4e8ff;
        }

        #multi-select-btn.active {
            background-color: #d93025 !important;
            color: #ffffff !important;
            border: 1px solid #ffffff;
        }

        #video-overlay {
            position: fixed; /* Changed from absolute to fixed */
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video-player-container {
            position: relative;
            width: 80%;
            height: 80%;
        }

        #video-player {
            width: 100%;
            height: 100%;
        }

        #video-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            background: #fff;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
        }

        #video-prev-btn, #video-next-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            background: #fff;
            border: none;
            font-size: 24px;
            padding: 10px;
        }

        #video-prev-btn {
            left: 10px;
        }

        #video-next-btn {
            right: 10px;
        }

        /* Style for dropdown menus to match button height */
        select {
            height: 36px;
            padding: 0 8px 0 8px;
            padding-right: 32px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            text-align: center;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
        }

        #size-selector {
            padding: 0 8px 0 8px;
            padding-right: 32px;
        }

        select:focus {
            outline: none;
            border-color: #166fe5;
        }

        select option {
            padding: 8px 12px;
            background-color: #ffffff;
            color: #000000;
            text-align: center;
        }

        select option:nth-child(even) {
            background-color: #f2f2f2;
        }

        /* Style for top-bar buttons */
        .top-bar button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }

        .top-bar button:hover {
            background-color: #166fe5;
        }

        .top-bar button:disabled {
            background-color: #666666;
            cursor: not-allowed;
        }

        #landscape-buttons button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }

        #landscape-buttons button:hover {
            background-color: #166fe5;
        }

        #landscape-buttons button:not(:first-child) {
            border-left: none;
        }

        #landscape-buttons button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }


        /* Style for layout name input */
        #layout-name-input {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            width: 120px;
        }

        #layout-name-input:focus {
            outline: none;
            border-color: #166fe5;
        }

        #layout-name-input::placeholder {
            color: #ffffff;
            opacity: 0.7;
        }

        .dropdown {
            position: relative;
            height: 100%;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #ffffff;
            color: #000000;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            max-height: calc(100vh - 72px); /* Full height minus top and bottom bars */
            overflow-y: auto;
        }

        .dropdown-content a {
            color: #000000;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }

        .dropdown-content a:nth-child(even) {
            background-color: #f2f2f2;
        }

        .dropdown-content a:hover {
            background-color: #1877f2;
            color: #ffffff;
        }

        .nested-dropdown {
            position: relative;
        }

        .nested-dropdown-content {
            display: none;
            position: fixed; /* Changed from absolute to fixed */
            background-color: #ffffff;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 3000; /* Ensure it's on top of everything */
        }

        .sidebar-section button.selected-for-removal,
        #sidebar-scroll-container button.selected-for-removal {
            background-color: #d93025 !important;
            color: #ffffff !important;
            border: 1px solid #ffffff;
        }

        .disabled-btn {
            background-color: #666666 !important;
            cursor: not-allowed !important;
        }

        /* Styles for the new filename builder panel */
        .filename-builder-modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 24px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 720px; /* Wider for more complex builder */
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: fadeIn 0.3s;
            color: #000000; /* Set default text color for the modal */
        }

        #filename-preview {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-family: monospace;
            min-height: 24px;
            border: 1px solid #ddd;
            word-wrap: break-word;
            white-space: pre-wrap; /* Allow line breaks */
        }

        .filename-part-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .filename-part-row input[type="text"],
        .filename-part-row select {
            flex-grow: 1;
            margin-right: 8px;
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #ffffff;
            color: #000000;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
        }

        .filename-part-row button {
            height: 36px;
            width: 36px;
            border: 1px solid #444444;
            background-color: #f2f2f2;
            color: #000000;
            cursor: pointer;
        }

        #add-filename-part-controls {
            display: flex;
            align-items: center;
            margin-top: 15px;
        }
        
        #add-filename-part-controls button {
            height: 36px;
            width: 36px;
            margin-right: 8px;
             border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            font-size: 20px;
            cursor: pointer;
        }

         #add-filename-part-controls select {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #ffffff;
            color: #000000;
         }

        #create-filename-button-btn {
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 16px;
            cursor: pointer;
            display: block;
            margin-top: 20px;
        }

        #list-view-controls {
            position: absolute;
            top: 40px; 
            left: 20px;
            z-index: 100;
        }

        #list-view-cog-btn {
            font-size: 24px;
            cursor: pointer;
            background: none;
            border: none;
            color: #1877f2;
        }

        #list-view-dropdown {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #list-view-dropdown label {
            display: block;
            color: black;
        }
        .list-view-toggle-btn {
            height: 36px;
            padding: 0 12px;
            border: 1px solid #444444;
            border-left: none;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            cursor: pointer;
        }
        .list-view-toggle-btn.active {
            background-color: #d93025;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div id="sidebar-resizer"></div>
            <div class="sidebar-buttons">
                <div class="dropdown">
                    <button class="sidebar-cog-btn" id="cog-btn">âš™</button>
                    <div class="dropdown-content" id="cog-dropdown">
                        <div id="project-username-container" style="padding: 12px 16px;">
                            <label for="project-username-input" style="display: block; margin-bottom: 5px;">Project Username</label>
                            <input type="text" id="project-username-input" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <a href="#" id="rename-canvas-btn">Rename Canvas</a>
                        <a href="#" id="manual-rename-btn">Manual Rename</a>
                        <a href="#" id="scan-for-buttons-btn">Scan for Buttons</a>
                        <a href="#" id="remove-all-buttons-btn">Remove All Buttons</a>
                        <div class="nested-dropdown" id="thumbnails-menu">
                            <a href="#">Thumbnails</a>
                            <div class="nested-dropdown-content" id="thumbnails-menu-list">
                                <a href="#" id="generate-folder-thumbnails-btn">Generate folder thumbnails</a>
                                <a href="#" id="refresh-thumbnails-btn">Refresh Thumbnails</a>
                                <a href="#" id="generate-edit-thumbnails-btn">Generate Thumbnails for Edit Mode</a>
                                <a href="#" id="generate-edit-thumbnails-new-btn">Generate Thumbnails for Edit Mode for New Files</a>
                            </div>
                        </div>
                        <div id="edit-mode-options" style="display:none;">
                            <a href="#" id="edit-mode-btn">Edit Mode: Off</a>
                            <a href="#" id="generate-edit-bat-btn">Generate Edit Bat</a>
                        </div>
                        <a href="#" id="generate-move-rename-script-btn">Generate Move Script</a>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="num-elements-input" style="display: block; margin-bottom: 5px;">Number of Elements</label>
                            <input type="number" id="num-elements-input" min="1" value="1" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                             <a href="#" id="visible-buttons-btn">Visible Buttons</a>
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="font-size-slider" style="display: block; margin-bottom: 5px;">Button Font Size</label>
                            <input type="range" id="font-size-slider" min="8" max="24" value="14" style="width: 100%;">
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="vertical-padding-input" style="display: block; margin-bottom: 5px;">Vertical Padding (px)</label>
                            <input type="number" id="vertical-padding-input" min="0" value="10" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="horizontal-padding-input" style="display: block; margin-bottom: 5px;">Horizontal Padding (px)</label>
                            <input type="number" id="horizontal-padding-input" min="0" value="10" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="preview-vertical-padding-input" style="display: block; margin-bottom: 5px;">Preview Vertical Padding (px)</label>
                            <input type="number" id="preview-vertical-padding-input" min="0" value="5" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <div class="nested-dropdown" id="recent-directories-dropdown">
                            <a href="#">Recent Directories</a>
                            <div class="nested-dropdown-content" id="recent-directories-list">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                        <a href="#" id="import-project-btn">Import Project</a>
                        <a href="#" id="export-project-btn">Export Project</a>
                        <a href="#" id="recalculate-suffix-btn">Recalculate Suffix</a>
                        <a href="#" id="information-btn">Information</a>
                    </div>
                </div>
                <button id="load-directory-btn">Load Directory</button>
            </div>
            <div id="sidebar-scroll-container">
                <!-- Custom buttons will be loaded here -->
            </div>
        </div>
        <div class="main-content">
            <div class="top-bar">
                <button id="test-hook-load-dir" style="display:none;">Test Hook</button>
                <button id="test-hook-load-padding-dir" style="display:none;">Test Hook Padding</button>
                <select id="size-selector">
                    <option value="list">List</option>
                    <option value="0.2">20%</option>
                    <option value="0.3">30%</option>
                    <option value="0.4">40%</option>
                    <option value="0.5">50%</option>
                    <option value="0.6">60%</option>
                    <option value="0.7">70%</option>
                    <option value="0.8">80%</option>
                    <option value="0.9">90%</option>
                    <option value="1" selected>100%</option>
                </select>
                <select id="sort-selector">
                    <option value="" disabled hidden>Sort</option>
                    <option value="name">Name</option>
                    <option value="random">Random</option>
                </select>
                <input type="text" id="layout-name-input" placeholder="Layout Name">
                <button id="save-layout-btn">Save Layout</button>
                <select id="layout-select">
                    <option value="" disabled hidden>Layout Select</option>
                </select>
                <button id="load-layout-btn">Load Layout</button>
                <button id="delete-layout-btn">Delete Layout</button>
                <button id="multi-select-btn">Multi Select</button>
                <button id="deselect-all-btn">Deselect All</button>
                <button id="hide-btn" disabled>Hide</button>
                <button id="split-btn" disabled>Split</button>
                <select id="canvas-select">
                    <option value="1">Canvas 1</option>
                </select>
                <select id="send-to-canvas-select" disabled>
                    <option value="" disabled hidden>Send to...</option>
                </select>
                <button id="close-canvas-btn" disabled>Close Canvas</button>
                <button id="toggle-last-canvas-btn" style="display: none;">Toggle Last</button>
                <button id="play-btn" disabled>Play</button>
                <button id="delete-selected-btn" disabled>Delete</button>
                <button id="preview-btn">Preview</button>
            </div>
            <div id="content-area" style="display: flex; flex-grow: 1; overflow: hidden;">
                <div id="thumbnail-container">
                    <div id="selection-box"></div>
                    <div id="content-spacer" style="position: absolute; top: 0; left: 0; z-index: -1;"></div>
                </div>
                <div class="right-sidebar" id="right-sidebar" style="display: none;">
                    <div id="right-sidebar-resizer"></div>
                    <div class="preview-header">
                        <h3>Preview</h3>
                        <button id="play-all-preview-btn" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer;">&#9658;</button>
                        <select id="preview-size-selector">
                            <option value="list">List</option>
                            <option value="0.2">20%</option>
                            <option value="0.3">30%</option>
                            <option value="0.4">40%</option>
                            <option value="0.5" selected>50%</option>
                            <option value="0.6">60%</option>
                            <option value="0.7">70%</option>
                            <option value="0.8">80%</option>
                            <option value="0.9">90%</option>
                            <option value="1">100%</option>
                        </select>
                    </div>
                    <div id="preview-container"></div>
                </div>
            </div>
            <div class="bottom-bar">
                <div style="display: flex;" id="bottom-bar-left-controls">
                    <button id="new-filename-btn" style="height: 36px; padding: 0; width: 60px; text-align: center; border: 1px solid #444444; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer;">New</button>
                    <button id="remove-btn" style="height: 36px; padding: 0 12px; border: 1px solid #444444; border-left: none; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer;">Remove</button>
                    <button id="copy-button-btn" style="height: 36px; padding: 0 12px; border: 1px solid #444444; border-left: none; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer;" disabled>Copy</button>
                    <button id="rename-btn" style="height: 36px; padding: 0 12px; border: 1px solid #444444; border-left: none; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer;" disabled>Rename</button>
                    <button id="toggle-renamed-canvas-btn" style="height: 36px; padding: 0 12px; border: 1px solid #444444; border-left: none; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer; display: none;">Toggle Renamed</button>
                    <div id="writing-element-controls" style="display: flex; align-items: center; border: 1px solid #444; border-left: none; padding: 0 5px;">
                        <input type="checkbox" id="add-writing-element-checkbox" title="Add Writing element">
                        <input type="number" id="writing-element-number-input" value="1" style="width: 40px; height: 24px; text-align: center; background-color: #ffffff; color: black; border: 1px solid #444;">
                    </div>
                    <div id="list-view-button-controls" style="display: none;">
                        <button id="show-thumbnails-btn" class="list-view-toggle-btn">Show Thumbs</button>
                        <button id="show-canvas-name-btn" class="list-view-toggle-btn">Show Canvas</button>
                        <button id="show-original-filename-btn" class="list-view-toggle-btn">Show Original Name</button>
                    </div>
                </div>
                <div id="bottom-bar-info" style="flex-grow: 1; text-align: right;"></div>
                <div id="landscape-buttons" style="display: none;">
                    <button id="deselect-row-btn">Deselect</button>
                    <button id="landscape-btn">Landscape</button>
                    <button id="landscape-rotate-btn">Landscape Rotate</button>
                    <button id="delete-btn">Delete</button>
                    <button id="edit-btn">Edit</button>
                    <button id="shortcut-btn">Create Shortcut</button>
                    <button id="select-btn">Select</button>
                </div>
            </div>
        </div>
    </div>

    <div id="filename-builder-modal" class="modal">
        <div class="filename-builder-modal-content">
            <span class="close">&times;</span>
            <h2>Create New Filename Button</h2>
            <p>Define a category and add one or more elements to create a button.</p>
            
            <h4>Preview:</h4>
            <div id="filename-preview"></div>

            <div id="filename-parts-container">
                <!-- Dynamic parts will be added here -->
            </div>

            <datalist id="previous-categories-list"></datalist>
            <datalist id="previous-elements-list"></datalist>

            <div id="add-filename-part-controls">
                <button id="add-element-btn">+</button>
            </div>

            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <button id="create-filename-button-btn">Add Button</button>
                <button id="clone-filename-button-btn" style="display: none;">Clone Button</button>
            </div>
            <input type="hidden" id="editing-button-id">
        </div>
    </div>

    <div id="video-overlay" style="display: none;">
        <div id="video-player-container">
            <video id="video-player" controls></video>
            <div id="video-filename-display" style="text-align: center; color: white; padding-top: 10px;"></div>
            <button id="video-close-btn">X</button>
            <button id="video-prev-btn">&lt;&lt;</button>
            <button id="video-next-btn">&gt;&gt;</button>
        </div>
    </div>

    <div id="script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Generate Thumbnails</h2>
            <p>The "Thumbnails" subdirectory is missing. Here is a batch script to generate them. You will need FFmpeg installed and in your system's PATH.</p>
            <textarea id="batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-script-btn">Copy to Clipboard</button>
            <a id="download-script-link" download="generate_thumbnails.bat">
                <button>Download .bat File</button>
            </a>
            <button id="reload-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>
    
    <div id="visible-buttons-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Visible Buttons</h2>
            <p>Select which buttons to display in the sidebar.</p>
            <div id="visible-buttons-list-container" style="max-height: 400px; overflow-y: auto;">
                <!-- Button visibility controls will be dynamically added here -->
            </div>
        </div>
    </div>

    <div id="edit-script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Generate Edit Thumbnails</h2>
            <p>This script will extract 10 screenshots from each video. You will need FFmpeg installed and in your system's PATH.</p>
            <textarea id="edit-batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-edit-script-btn">Copy to Clipboard</button>
            <a id="download-edit-script-link" download="generate_edit_thumbnails.bat">
                <button>Download .bat File</button>
            </a>
            <button id="reload-edit-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>

    <div id="final-landscape-script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Final Processing PowerShell Script</h2>
            <p>This script will process your selections. Right-click and "Run with PowerShell" in your main video directory.</p>
            <textarea id="final-landscape-batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-final-landscape-script-btn">Copy to Clipboard</button>
            <a id="download-final-landscape-script-link" download="process_selections.ps1">
                <button>Download .ps1 File</button>
            </a>
            <button id="reload-final-script-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>

    <div id="move-rename-script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Move and Rename PowerShell Script</h2>
            <p>This script will move and rename your files. Right-click and "Run with PowerShell" in your main video directory.</p>
            <textarea id="move-rename-batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-move-rename-script-btn">Copy to Clipboard</button>
            <a id="download-move-rename-script-link" download="move_rename.ps1">
                <button>Download .ps1 File</button>
            </a>
            <button id="reload-move-rename-script-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>

    <div id="orphaned-thumbnails-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Orphaned Thumbnails Found</h2>
            <p id="orphaned-thumbnails-message"></p>
            <div id="orphaned-files-list" style="max-height: 150px; overflow-y: auto; background-color: #f0f0f0; border: 1px solid #ccc; padding: 5px; margin-bottom: 10px; color: black;"></div>
            <button id="delete-orphans-script-btn">Generate Deletion Script</button>
            <button id="hide-orphans-btn">Hide Them</button>
            <button id="hide-forever-orphans-btn">Hide Forever</button>
            <button id="do-nothing-orphans-btn">Do Nothing</button>
        </div>
    </div>

    <script>
        // --- IndexedDB Helpers ---
        function getDb(key) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('thumbnail-tool-db', 1);
                request.onupgradeneeded = () => request.result.createObjectStore('store');
                request.onsuccess = () => {
                    const tx = request.result.transaction('store', 'readonly');
                    const store = tx.objectStore('store');
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                    tx.oncomplete = () => request.result.close();
                };
                request.onerror = () => reject(request.error);
            });
        }


        function setDb(key, value) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('thumbnail-tool-db', 1);
                request.onupgradeneeded = () => request.result.createObjectStore('store');
                request.onsuccess = () => {
                    const tx = request.result.transaction('store', 'readwrite');
                    const store = tx.objectStore('store');
                    const req = store.put(value, key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                    tx.oncomplete = () => request.result.close();
                };
                request.onerror = () => reject(request.error);
            });
        }

        // --- New LocalStorage Helpers ---
        const APP_VERSION = "2.0";

        function loadProjectData(dirName) {
            const rawData = localStorage.getItem(`projectData-${dirName}`);
            let data = {
                version: APP_VERSION,
                projectUsername: '',
                numElements: 1,
                fontSize: 14,
                verticalPadding: 10,
                horizontalPadding: 10,
                previewVerticalPadding: 5,
                customButtonTree: [],
                collapseState: {},
                buttonVisibility: {},
                canvases: null,
                layouts: {},
                previewSidebarVisible: false,
                previewSidebarWidth: 250,
                previewThumbnailSize: '0.5',
                addWritingElement: false,
                writingElementNumber: 1,
                hiddenOrphans: [],
                listViewShowThumbnails: false,
                listViewShowCanvasName: false,
                listViewShowOriginalFilename: false
            };

            if (rawData) {
                try {
                    const savedData = JSON.parse(rawData);
                    // Merge saved data, ensuring all keys from the default object are present
                    data = { ...data, ...savedData };
                } catch (e) {
                    console.error("Failed to parse project data, using defaults.", e);
                }
            }
            return data;
        }

        function saveProjectData(dirName, data) {
            data.version = APP_VERSION;
            localStorage.setItem(`projectData-${dirName}`, JSON.stringify(data));
        }

        const directoryPicker = document.getElementById('directory-picker');
        const thumbnailContainer = document.getElementById('thumbnail-container');
        const scriptModal = document.getElementById('script-modal');
        const filenameBuilderModal = document.getElementById('filename-builder-modal');
        const batchScriptTextArea = document.getElementById('batch-script');
        const copyScriptBtn = document.getElementById('copy-script-btn');
        const downloadScriptLink = document.getElementById('download-script-link');
        const reloadPageBtn = document.getElementById('reload-page-btn');
        const sizeSelector = document.getElementById('size-selector');
        let isLayoutFrozen = false;
        var directoryName = '';
        let zIndexCounter = 1000;
        const loadButton = document.getElementById('load-directory-btn');
        const saveLayoutBtn = document.getElementById('save-layout-btn');
        const layoutNameInput = document.getElementById('layout-name-input');
        const layoutSelect = document.getElementById('layout-select');
        const loadLayoutBtn = document.getElementById('load-layout-btn');
        const deleteLayoutBtn = document.getElementById('delete-layout-btn');
        const selectionBox = document.getElementById('selection-box');
        const contentSpacer = document.getElementById('content-spacer');
        let selectedThumbnails = new Set();
        let selectedPreviewThumbnails = new Set();
        let allVideoFiles = [];
        const playBtn = document.getElementById('play-btn');
        let scanLayouts = {};
        const splitBtn = document.getElementById('split-btn');
        const canvasSelect = document.getElementById('canvas-select');
        const multiSelectBtn = document.getElementById('multi-select-btn');
        const sendToCanvasSelect = document.getElementById('send-to-canvas-select');
        const closeCanvasBtn = document.getElementById('close-canvas-btn');
        const renameCanvasBtn = document.getElementById('rename-canvas-btn');
        const scanForButtonsBtn = document.getElementById('scan-for-buttons-btn');
        const removeAllButtonsBtn = document.getElementById('remove-all-buttons-btn');
        const deselectAllBtn = document.getElementById('deselect-all-btn');
        const hideBtn = document.getElementById('hide-btn');
        let isMultiSelectMode = false;
        const sortSelector = document.getElementById('sort-selector');
        const cogBtn = document.getElementById('cog-btn');
        const newFilenameBtn = document.getElementById('new-filename-btn');
        const removeBtn = document.getElementById('remove-btn');
        const renameBtn = document.getElementById('rename-btn');
        const visibleButtonsBtn = document.getElementById('visible-buttons-btn');
        const visibleButtonsModal = document.getElementById('visible-buttons-modal');
        const visibleButtonsListContainer = document.getElementById('visible-buttons-list-container');
        const thumbnailsMenu = document.getElementById('thumbnails-menu');
        const generateFolderThumbnailsBtn = document.getElementById('generate-folder-thumbnails-btn');
        const refreshThumbnailsBtn = document.getElementById('refresh-thumbnails-btn');
        const generateEditThumbnailsBtn = document.getElementById('generate-edit-thumbnails-btn');
        const generateEditThumbnailsNewBtn = document.getElementById('generate-edit-thumbnails-new-btn');
        const editScriptModal = document.getElementById('edit-script-modal');
        const recentDirectoriesDropdown = document.getElementById('recent-directories-dropdown');
        const listViewButtonControls = document.getElementById('list-view-button-controls');
        const showThumbnailsBtn = document.getElementById('show-thumbnails-btn');
        const showCanvasNameBtn = document.getElementById('show-canvas-name-btn');
        const showOriginalFilenameBtn = document.getElementById('show-original-filename-btn');
        const previewBtn = document.getElementById('preview-btn');
        const rightSidebar = document.getElementById('right-sidebar');
        const previewContainer = document.getElementById('preview-container');
        
        let buttonsForRemoval = new Set();
        let filenameParts = [];
        const filenamePreview = document.getElementById('filename-preview');
        const filenamePartsContainer = document.getElementById('filename-parts-container');
        const addPartBtn = document.getElementById('add-part-btn');
        const createFilenameButtonBtn = document.getElementById('create-filename-button-btn');

        var canvases = new Map();
        let activeCanvasId = 1;
        let lastActiveCanvasId = null;
        let lastCanvasIdBeforeRenamed = null;
        let allThumbnails = [];
        let currentDirHandle;
        var landscapeSelectionMode = ''; // 'landscape' or 'landscape-rotate'
        let preEditModeCanvasMap = new Map();
        var landscapeSelections = new Set();
        var landscapeRotateSelections = new Set();
        var deleteSelections = new Set();
        var editSelections = new Set();
        var shortcutSelections = new Set();
        var playSelections = new Set();
        let originalPartsForCopyCheck = null;

        function updateSidebarActionButtonsState() {
            const numSelected = buttonsForRemoval.size;
            const copyBtn = document.getElementById('copy-button-btn');

            // Remove button state
            removeBtn.disabled = numSelected === 0;
            removeBtn.classList.toggle('disabled-btn', numSelected === 0);

            // Copy button state
            if (copyBtn) {
                copyBtn.disabled = numSelected !== 1;
                copyBtn.classList.toggle('disabled-btn', numSelected !== 1);
            }
        }

        function getNextCanvasId() {
            let i = 1;
            while (canvases.has(i)) {
                i++;
            }
            return i;
        }

        function renderCanvas(canvasId) {
            activeCanvasId = canvasId;
            thumbnailContainer.innerHTML = ''; // Clear container
            thumbnailContainer.appendChild(selectionBox);
            thumbnailContainer.appendChild(contentSpacer);

            const canvas = canvases.get(canvasId);
            if (canvas) {
                document.title = canvas.name;
                hideBtn.textContent = canvas.name === 'Hidden' ? 'Unhide' : 'Hide';
                canvas.thumbnails.forEach(thumb => {
                    const canvasNamePlaceholder = thumb.querySelector('.canvas-name-placeholder');
                    if (canvasNamePlaceholder) {
                        canvasNamePlaceholder.textContent = canvas.name;
                    }
                    thumbnailContainer.appendChild(thumb);
                });
            }

            const currentCanvas = canvases.get(activeCanvasId);
            closeCanvasBtn.disabled = !(currentCanvas && currentCanvas.thumbnails.length === 0 && canvases.size > 1 && currentCanvas.name !== 'Renamed');
            
            const toggleRenamedBtn = document.getElementById('toggle-renamed-canvas-btn');
            const renamedCanvas = Array.from(canvases.values()).find(c => c.name === 'Renamed');
            if (renamedCanvas) {
                toggleRenamedBtn.style.display = 'inline-block';
            } else {
                toggleRenamedBtn.style.display = 'none';
            }

            populateCanvasDropdown();
            
            const currentSettings = currentCanvas ? (currentCanvas.settings || { thumbnailSize: '1' }) : { thumbnailSize: '1' };
            sizeSelector.value = currentSettings.thumbnailSize;

            const currentSize = sizeSelector.value;
            listViewButtonControls.style.display = currentSize === 'list' ? 'flex' : 'none';
            if (currentSize === 'list') {
                layoutThumbnailsInList();
            } else {
                layoutThumbnailsInGrid();
            }
        }

        function populateCanvasDropdown() {
            canvasSelect.innerHTML = '';
            sendToCanvasSelect.innerHTML = '<option value="" disabled selected hidden>Send to...</option>';
            for (const canvas of canvases.values()) {
                const option = document.createElement('option');
                option.value = canvas.id;
                option.textContent = canvas.name;
                canvasSelect.appendChild(option.cloneNode(true));
                if (canvas.id !== activeCanvasId) {
                    sendToCanvasSelect.appendChild(option);
                }
            }
            canvasSelect.value = activeCanvasId;
        }

        const videoOverlay = document.getElementById('video-overlay');
        const videoPlayer = document.getElementById('video-player');
        const videoCloseBtn = document.getElementById('video-close-btn');
        const videoPrevBtn = document.getElementById('video-prev-btn');
        const videoNextBtn = document.getElementById('video-next-btn');
        let playlist = [];
        let currentPlaylistIndex = -1;
        let currentVideoUrl = null;

        function saveCanvasState() {
            if (!directoryName) return;

            const canvasData = {
                canvases: Array.from(canvases.values()).map(c => ({
                    id: c.id,
                    name: c.name,
                    settings: c.settings || { thumbnailSize: '1' }, // Save settings per canvas
                    thumbnails: c.thumbnails.map(t => {
                        const nameDiv = t.querySelector('.thumbnail-name');
                        return {
                            fileName: t.dataset.fileName, // The current (potentially new) name
                            originalFilename: nameDiv ? nameDiv.dataset.originalFilename : t.dataset.fileName,
                            left: t.style.left,
                            top: t.style.top,
                            previousCanvasId: t.dataset.previousCanvasId
                        };
                    })
                })),
                activeCanvasId: activeCanvasId
            };
            const projectData = loadProjectData(directoryName);
            projectData.canvases = canvasData;
            saveProjectData(directoryName, projectData);
        }

        function loadVideo(index) {
            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
            }
            
            currentPlaylistIndex = index;
            const thumbWrapper = playlist[index];
            const nameDiv = thumbWrapper.querySelector('.thumbnail-name');
            const originalFilename = nameDiv ? nameDiv.dataset.originalFilename : thumbWrapper.dataset.fileName;

            document.getElementById('video-filename-display').textContent = originalFilename;

            if (!originalFilename) {
                console.error("Could not find an original filename for the selected thumbnail.", thumbWrapper);
                return;
            }
            const thumbName = originalFilename.substring(0, originalFilename.lastIndexOf('.'));

            // Find the video file by matching the base name, ignoring the extension
            const videoFile = allVideoFiles.find(f => f.name.substring(0, f.name.lastIndexOf('.')) === thumbName);
            
            if (videoFile) {
                currentVideoUrl = URL.createObjectURL(videoFile);
                videoPlayer.src = currentVideoUrl;
                videoPlayer.play();
            } else {
                console.error(`Video file not found for thumbnail: ${thumbName}`);
                console.log('Available video files:', allVideoFiles.map(f => f.name));
                alert(`Could not find the video file for ${originalFilename}. Check the console for more details.`);
            }

            videoPrevBtn.style.display = index > 0 ? 'block' : 'none';
            videoNextBtn.style.display = index < playlist.length - 1 ? 'block' : 'none';
        }

        function updatePlayButtonState() {
            const editModeBtn = document.getElementById('edit-mode-btn');
            const inEditMode = editModeBtn && editModeBtn.textContent.includes('On');
            const renameBtn = document.getElementById('rename-btn');
            const deleteBtn = document.getElementById('delete-selected-btn');

            if (inEditMode) {
                playBtn.disabled = playSelections.size === 0;
                splitBtn.disabled = true;
                sendToCanvasSelect.disabled = true;
                hideBtn.disabled = true;
                renameBtn.disabled = true; // Disable in edit mode
                deleteBtn.disabled = true;
            } else {
                const numThumbSelected = selectedThumbnails.size;
                const numButtonSelected = buttonsForRemoval.size;

                playBtn.disabled = numThumbSelected === 0 && numButtonSelected !== 1;
                splitBtn.disabled = numThumbSelected === 0;
                sendToCanvasSelect.disabled = numThumbSelected === 0;
                hideBtn.disabled = numThumbSelected === 0;
                deleteBtn.disabled = numThumbSelected === 0;

                const currentCanvas = canvases.get(activeCanvasId);
                const isRenamedCanvas = currentCanvas && currentCanvas.name === 'Renamed';
                renameBtn.disabled = numThumbSelected === 0 || isRenamedCanvas;
            }
        }

        function updateContentSpacer() {
            const wrappers = document.querySelectorAll('.thumbnail-wrapper');
            if (wrappers.length === 0) {
                contentSpacer.style.width = '0px';
                contentSpacer.style.height = '0px';
                return;
            }

            let maxRight = 0;
            let maxBottom = 0;

            wrappers.forEach(wrapper => {
                const right = wrapper.offsetLeft + wrapper.offsetWidth;
                const bottom = wrapper.offsetTop + wrapper.offsetHeight;
                if (right > maxRight) maxRight = right;
                if (bottom > maxBottom) maxBottom = bottom;
            });

            // Add a small buffer
            contentSpacer.style.width = (maxRight + 20) + 'px';
            contentSpacer.style.height = (maxBottom + 20) + 'px';
        }

        async function init() {
            let directoryLoaded = false;
            try {
                const dirHandle = await getDb('lastDirectory');
                if (dirHandle && typeof dirHandle.queryPermission === 'function') {
                    // Only check for existing permission; don't request it on page load.
                    if (await dirHandle.queryPermission({ mode: 'read' }) === 'granted') {
                        await processDirectory(dirHandle);
                        directoryLoaded = true;
                    } else {
                        console.log('Permission for last directory not granted. Waiting for user action.');
                    }
                }
            } catch (e) {
                console.error('Error during auto-load:', e);
            } finally {
                // If no directory was loaded (either due to no handle, no permission, or error),
                // initialize a clean UI.
                if (!directoryLoaded) {
                    initializeUI();
                }
            }
        }

        function initializeUI() {
            const projectData = loadProjectData(directoryName);
            loadRecentDirectories();
            updateSidebarActionButtonsState();

            document.getElementById('copy-button-btn').addEventListener('click', () => {
                if (buttonsForRemoval.size === 1) {
                    const buttonId = buttonsForRemoval.values().next().value;
                    openButtonEditor(buttonId);
                }
            });

            recentDirectoriesDropdown.addEventListener('click', (event) => {
                event.stopPropagation();
                const list = document.getElementById('recent-directories-list');
                const button = event.currentTarget;
                const rect = button.getBoundingClientRect();

                if (list.style.display === 'block') {
                    list.style.display = 'none';
                } else {
                    list.style.display = 'block';
                    list.style.top = `${rect.top}px`;
                    list.style.left = `${rect.right}px`;
                }
            });

            const numElementsInput = document.getElementById('num-elements-input');
            numElementsInput.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.numElements = numElementsInput.value;
                saveProjectData(directoryName, projectData);
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
            });

            const fontSizeSlider = document.getElementById('font-size-slider');
            fontSizeSlider.addEventListener('input', () => {
                const buttons = document.querySelectorAll('#sidebar-scroll-container button');
                buttons.forEach(button => {
                    button.style.fontSize = `${fontSizeSlider.value}px`;
                    adjustButtonFontSize(button);
                });
            });
            fontSizeSlider.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.fontSize = fontSizeSlider.value;
                saveProjectData(directoryName, projectData);
            });

            const verticalPaddingInput = document.getElementById('vertical-padding-input');
            verticalPaddingInput.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.verticalPadding = verticalPaddingInput.value;
                saveProjectData(directoryName, projectData);
                isLayoutFrozen = false;
                layoutThumbnailsInGrid();
            });

            const previewVerticalPaddingInput = document.getElementById('preview-vertical-padding-input');
            previewVerticalPaddingInput.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.previewVerticalPadding = previewVerticalPaddingInput.value;
                saveProjectData(directoryName, projectData);
                const currentPreviewSize = document.getElementById('preview-size-selector').value;
                layoutPreviewPane(currentPreviewSize);
            });

            const horizontalPaddingInput = document.getElementById('horizontal-padding-input');
            horizontalPaddingInput.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.horizontalPadding = horizontalPaddingInput.value;
                saveProjectData(directoryName, projectData);
                isLayoutFrozen = false;
                layoutThumbnailsInGrid();
            });

            const addWritingElementCheckbox = document.getElementById('add-writing-element-checkbox');
            const writingElementNumberInput = document.getElementById('writing-element-number-input');

            addWritingElementCheckbox.checked = projectData.addWritingElement;
            writingElementNumberInput.value = projectData.writingElementNumber;

            addWritingElementCheckbox.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.addWritingElement = addWritingElementCheckbox.checked;
                saveProjectData(directoryName, projectData);
            });

            writingElementNumberInput.addEventListener('change', () => {
                const projectData = loadProjectData(directoryName);
                projectData.writingElementNumber = writingElementNumberInput.value;
                saveProjectData(directoryName, projectData);
            });
        }

        loadButton.addEventListener('click', async () => {
            try {
                const dirHandle = await window.showDirectoryPicker();
                await processDirectory(dirHandle);
            } catch (err) {
                if (err.name !== 'AbortError') console.error('Failed to open directory:', err);
            }
        });

        cogBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const dropdown = document.getElementById('cog-dropdown');
            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        });

        // Prevent clicks inside the dropdown from closing it
        document.getElementById('cog-dropdown').addEventListener('click', (event) => {
            event.stopPropagation();
        });

        thumbnailsMenu.addEventListener('click', (event) => {
            event.stopPropagation();
            const list = document.getElementById('thumbnails-menu-list');
            list.style.display = list.style.display === 'block' ? 'none' : 'block';
        });

        generateEditThumbnailsBtn.addEventListener('click', () => {
            if (allVideoFiles.length === 0) {
                alert('No video files loaded. Please load a directory first.');
                return;
            }
            generateEditBatchScript(allVideoFiles);
            editScriptModal.style.display = 'block';
        });

        editScriptModal.querySelector('.close').addEventListener('click', () => {
            editScriptModal.style.display = 'none';
        });

        document.getElementById('copy-edit-script-btn').addEventListener('click', () => {
            const scriptTextArea = document.getElementById('edit-batch-script');
            scriptTextArea.select();
            navigator.clipboard.writeText(scriptTextArea.value).then(() => {
                alert('Script copied to clipboard!');
                document.getElementById('reload-edit-page-btn').style.display = 'inline-block';
            });
        });

        document.getElementById('download-edit-script-link').addEventListener('click', () => {
            document.getElementById('reload-edit-page-btn').style.display = 'inline-block';
        });

        document.getElementById('reload-edit-page-btn').addEventListener('click', () => {
            location.reload();
        });

        document.getElementById('landscape-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'landscape' ? '' : 'landscape';
            updateSelectionModeButtons();
        });

        document.getElementById('landscape-rotate-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'landscape-rotate' ? '' : 'landscape-rotate';
            updateSelectionModeButtons();
        });

        document.getElementById('delete-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'delete' ? '' : 'delete';
            updateSelectionModeButtons();
        });

        document.getElementById('edit-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'edit' ? '' : 'edit';
            updateSelectionModeButtons();
        });

        document.getElementById('shortcut-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'shortcut' ? '' : 'shortcut';
            updateSelectionModeButtons();
        });

        document.getElementById('select-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'play' ? '' : 'play';
            updateSelectionModeButtons();
        });

        document.getElementById('deselect-row-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to deselect all rows?')) {
                landscapeSelections.clear();
                landscapeRotateSelections.clear();
                deleteSelections.clear();
                editSelections.clear();
                shortcutSelections.clear();
                playSelections.clear();

                document.querySelectorAll('.landscape-row').forEach(row => {
                    row.classList.remove('selected-landscape', 'selected-landscape-rotate', 'selected-delete', 'selected-edit', 'selected-shortcut', 'selected-play');
                });
            }
        });

        function updateSelectionModeButtons() {
            const blue = '#1877f2';
            const red = '#d93025';
            document.getElementById('landscape-btn').style.backgroundColor = landscapeSelectionMode === 'landscape' ? red : blue;
            document.getElementById('landscape-rotate-btn').style.backgroundColor = landscapeSelectionMode === 'landscape-rotate' ? red : blue;
            document.getElementById('delete-btn').style.backgroundColor = landscapeSelectionMode === 'delete' ? red : blue;
            document.getElementById('edit-btn').style.backgroundColor = landscapeSelectionMode === 'edit' ? red : blue;
            document.getElementById('shortcut-btn').style.backgroundColor = landscapeSelectionMode === 'shortcut' ? red : blue;
            document.getElementById('select-btn').style.backgroundColor = landscapeSelectionMode === 'play' ? red : blue;
        }


        const projectUsernameInput = document.getElementById('project-username-input');
        projectUsernameInput.addEventListener('change', () => {
            if (directoryName) {
                const projectData = loadProjectData(directoryName);
                projectData.projectUsername = projectUsernameInput.value;
                saveProjectData(directoryName, projectData);
            }
            updateFilenamePreview();
        });

        document.getElementById('project-username-container').addEventListener('click', (event) => {
            event.stopPropagation();
        });

        window.addEventListener('click', (event) => {
            const dropdown = document.getElementById('cog-dropdown');
            // If the click is outside the cog button AND outside the dropdown content
            if (!event.target.matches('.sidebar-cog-btn') && !dropdown.contains(event.target)) {
                if (dropdown.style.display === 'block') {
                    dropdown.style.display = 'none';
                    document.getElementById('recent-directories-list').style.display = 'none';
                }
            }
        });

        function findAndRenumberSequence(baseName, isRemoval = false) {
            const regex = new RegExp(`^${escapeRegExp(baseName)} \\((\\d+)\\)`);
            const matchingFiles = allVideoFiles.filter(f => regex.test(f.name));

            matchingFiles.sort((a, b) => {
                const aNum = parseInt(a.name.match(regex)[1], 10);
                const bNum = parseInt(b.name.match(regex)[1], 10);
                return aNum - bNum;
            });

            if (isRemoval) {
                // Re-compact the sequence
                matchingFiles.forEach((file, index) => {
                    const expectedNum = index + 1;
                    const currentNum = parseInt(file.name.match(regex)[1], 10);

                    if (currentNum !== expectedNum) {
                        const extension = file.name.substring(file.name.lastIndexOf('.'));
                        const newFilename = `${baseName} (${expectedNum})${extension}`;
                        
                        // Find and update the UI
                        const thumb = findThumbnailByOriginalFilename(file.name);
                        if (thumb) {
                            thumb.dataset.fileName = newFilename;
                            thumb.querySelector('.thumbnail').dataset.fileName = newFilename;
                            thumb.querySelector('.thumbnail-name').textContent = newFilename;
                        }
                        // Update the master file list
                        file.name = newFilename;
                    }
                });
                return -1; // Indicate renumbering happened
            } else {
                // Find the next available number
                let nextNumber = 1;
                for (const file of matchingFiles) {
                    const currentNum = parseInt(file.name.match(regex)[1], 10);
                    if (currentNum === nextNumber) {
                        nextNumber++;
                    } else {
                        break; // Found a gap
                    }
                }
                return nextNumber;
            }
        }
        
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
        }

        function findThumbnailByOriginalFilename(originalFilename) {
             const thumbName = originalFilename.replace(/\.[^/.]+$/, ".jpg");
             return Array.from(document.querySelectorAll('.thumbnail-wrapper')).find(w => {
                const nameDiv = w.querySelector('.thumbnail-name');
                return nameDiv && nameDiv.dataset.originalFilename === thumbName;
            });
        }


        function renumberFiles(targetFolder, startingNumber) {
            const filesInFolder = allVideoFiles.filter(file => file.customPath === targetFolder && /^\d+$/.test(file.name.substring(0, file.name.lastIndexOf('.'))));
            
            // Sort files numerically based on their current names
            filesInFolder.sort((a, b) => {
                const numA = parseInt(a.name.substring(0, a.name.lastIndexOf('.')), 10);
                const numB = parseInt(b.name.substring(0, b.name.lastIndexOf('.')), 10);
                return numA - numB;
            });

            let currentNumber = startingNumber;
            filesInFolder.forEach(file => {
                const originalName = file.name;
                const num = parseInt(originalName.substring(0, originalName.lastIndexOf('.')), 10);

                if (num >= startingNumber) {
                    const extension = originalName.substring(originalName.lastIndexOf('.'));
                    const newFilename = `${currentNumber}${extension}`;

                    // Find the corresponding thumbnail and update it
                    const thumb = Array.from(document.querySelectorAll('.thumbnail-wrapper')).find(t => t.dataset.fileName === originalName);
                    if (thumb) {
                        thumb.dataset.fileName = newFilename;
                        thumb.querySelector('.thumbnail').dataset.fileName = newFilename;
                        thumb.querySelector('.thumbnail-name').textContent = newFilename;
                    }
                    
                    // Update the file object itself for consistency
                    file.name = newFilename;

                    currentNumber++;
                }
            });
        }
        renameCanvasBtn.addEventListener('click', () => {
            const currentCanvas = canvases.get(activeCanvasId);
            if (!currentCanvas) return;

            const newName = prompt('Enter new name for the canvas:', currentCanvas.name);
            if (newName && newName.trim() !== '') {
                currentCanvas.name = newName.trim();
                saveCanvasState();
                populateCanvasDropdown();
                renderCanvas(activeCanvasId);
            }
        });

        document.getElementById('manual-rename-btn').addEventListener('click', () => {
            if (sizeSelector.value !== 'list') {
                alert('Manual rename is only available in list view.');
                return;
            }
            if (selectedThumbnails.size !== 1) {
                alert('Please select exactly one file to rename.');
                return;
            }

            const thumbnailWrapper = selectedThumbnails.values().next().value;
            const currentFilename = thumbnailWrapper.dataset.fileName;
            const newFilename = prompt('Enter new filename:', currentFilename);

            if (newFilename && newFilename.trim() !== '') {
                const trimmedNewFilename = newFilename.trim();
                thumbnailWrapper.dataset.fileName = trimmedNewFilename;
                thumbnailWrapper.querySelector('.thumbnail-name').textContent = trimmedNewFilename;
                thumbnailWrapper.querySelector('.new-filename-placeholder').textContent = trimmedNewFilename;
                saveCanvasState();
                layoutThumbnailsInList(); // Re-apply list view logic
            }
        });

        renameBtn.addEventListener('click', () => {
            const lastClickedButtonData = JSON.parse(renameBtn.dataset.lastClicked || 'null');
            if (!lastClickedButtonData) {
                alert('Please select a naming button from the sidebar first.');
                return;
            }
             if (selectedThumbnails.size === 0) {
                alert('Please select one or more thumbnails to rename.');
                return;
            }

            const renamedCanvas = Array.from(canvases.values()).find(c => c.name === 'Renamed');
            if (!renamedCanvas) {
                console.error("Renamed canvas not found!");
                return;
            }

            const selectedArray = Array.from(selectedThumbnails);
            const username = projectUsernameInput.value.trim() || 'username';

            // Trigger renumbering for the original filenames first
            const originalBaseNames = new Set();
            selectedArray.forEach(thumb => {
                const originalThumbName = thumb.querySelector('.thumbnail-name').dataset.originalFilename;
                const originalVideoName = originalThumbName.replace(/\.[^/.]+$/, '.mp4');
                const videoFile = allVideoFiles.find(f => f.name === originalVideoName);
                if (videoFile) {
                    originalBaseNames.add(getBaseName(videoFile.name));
                }
            });
            originalBaseNames.forEach(baseName => findAndRenumberSequence(baseName, true));


            const category = lastClickedButtonData.path[0];
            const prefix = `[${username}]_${category}`;
            const buttonText = lastClickedButtonData.fullButtonText;
            const startingNumbers = new Map();

            selectedArray.forEach((thumb) => {
                const originalThumbName = thumb.querySelector('.thumbnail-name').dataset.originalFilename;
                const originalVideoName = originalThumbName.replace(/\.[^/.]+$/, '.mp4');
                const videoFile = allVideoFiles.find(f => f.name === originalVideoName);

                let suffix = '';
                let writingElement = '';

                const addWritingElement = document.getElementById('add-writing-element-checkbox').checked;
                if (addWritingElement) {
                    const writingNumber = document.getElementById('writing-element-number-input').value;
                    writingElement = ` (Writing ${writingNumber})`;
                }

                if (videoFile && videoFile.customPath === 'Landscape') {
                    suffix = ' (Landscape)';
                } else if (videoFile && videoFile.customPath === 'Landscape Rotate') {
                    suffix = ' (Landscape) (Rotate)';
                }

                let baseName;
                if (lastClickedButtonData.specialType === 'plusOne') {
                    baseName = `${prefix}${writingElement}${suffix}`;
                } else {
                    baseName = `${prefix} ${buttonText}${writingElement}${suffix}`;
                }

                if (!startingNumbers.has(baseName)) {
                    startingNumbers.set(baseName, findAndRenumberSequence(baseName, false));
                }
                
                const nextNumber = startingNumbers.get(baseName);
                const extension = originalThumbName.substring(originalThumbName.lastIndexOf('.'));
                const newFilename = `${baseName} (${nextNumber})${extension.replace(/\.mp4$/i, '.jpg')}`;

                // Update the master file list first
                if(videoFile) {
                    videoFile.name = newFilename.replace(/\.jpg$/i, '.mp4');
                }

                // Update UI and data attributes
                thumb.dataset.fileName = newFilename;
                thumb.querySelector('.thumbnail').dataset.fileName = newFilename;
                thumb.querySelector('.thumbnail-name').textContent = newFilename;
                thumb.querySelector('.new-filename-placeholder').textContent = newFilename;

                startingNumbers.set(baseName, nextNumber + 1);
            });

            sendThumbnailsToCanvas(renamedCanvas.id, true); // True clears selection
            renderCanvas(activeCanvasId);
            saveCanvasState();

            updateSidebarActionButtonsState();
            updateBottomBarInfo(); // Re-show sidebar button info
            updatePreviewPanel(lastClickedButtonData); // Refresh the preview panel
        });

        removeAllButtonsBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to remove all custom buttons for this directory?')) {
                const projectData = loadProjectData(directoryName);
                projectData.customButtonTree = [];
                saveProjectData(directoryName, projectData);
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                alert('All custom buttons have been removed.');
            }
            document.getElementById('cog-dropdown').style.display = 'none';
        });

        function insertButtonIntoTree(tree, path, buttonData) {
            let currentLevel = tree;
            let node = null;

            for (let i = 0; i < path.length; i++) {
                const name = path[i];
                const isButton = i === path.length - 1;

                node = currentLevel.find(item => item.name === name && item.type === (isButton ? 'button' : 'category'));

                if (!node) {
                    node = {
                        name: name,
                        type: isButton ? 'button' : 'category',
                    };
                    if (isButton) {
                        Object.assign(node, { id: buttonData.id || Date.now() + Math.random(), ...buttonData });
                    } else {
                        node.children = [];
                    }
                    currentLevel.push(node);
                } else if (isButton) {
                    // If a button with the same path already exists, it's a duplicate.
                    return false; 
                }
                
                if (!isButton) {
                    currentLevel = node.children;
                }
            }
            return true; // Indicates a new button was successfully added
        }

        scanForButtonsBtn.addEventListener('click', async () => {
            let username = projectUsernameInput.value.trim();
            if (!username) {
                username = prompt('Please enter a Project Username to scan for matching filenames:');
                if (username) {
                    projectUsernameInput.value = username;
                    projectUsernameInput.dispatchEvent(new Event('change'));
                } else {
                    alert('Scan cancelled. A Project Username is required.');
                    return;
                }
            }

            const projectData = loadProjectData(directoryName);
            let customButtonTree = projectData.customButtonTree;
            let newButtonsCreated = 0;

            // Regex explained:
            // ^\\[${username}\\]_  - Matches "[username]_" at the start of the string.
            // ([^(]+)             - Captures the Category. Matches any character except '('. This is more flexible than \w+.
            // (.*)                 - Captures the rest of the string, which contains the elements.
            const regex = new RegExp(`^\\[${username}\\]_([^(]+)(.*)`);

            for (const file of allVideoFiles) {
                const match = file.name.match(regex);
                if (!match) continue;

                const category = match[1].trim();
                let rawElementsText = match[2] || '';
                
                // Clean up raw elements string: remove file extension and trailing number like (1)
                rawElementsText = rawElementsText.substring(0, rawElementsText.lastIndexOf('.')).trim();
                rawElementsText = rawElementsText.replace(/\s*\(\d+\)$/, '').trim();

                // Extract all parenthesized elements, e.g., "(Coat)" "(Black 1)"
                const elementsWithParens = rawElementsText.match(/\(([^)]+)\)/g) || [];
                
                if (elementsWithParens.length === 0) {
                    // This handles filenames like "[user]_Misc.mp4" or "[user]_Misc (1).mp4"
                    // A special "+1" button is created for simple renaming.
                    const path = [category, '+1'];
                    const buttonData = {
                        fullButtonText: '',
                        specialType: 'plusOne'
                    };
                    if (insertButtonIntoTree(customButtonTree, path, buttonData)) {
                        newButtonsCreated++;
                    }
                } else {
                    // This handles hierarchical names like "[user]_Misc (Coat) (Black 1).mp4"
                    // 1. Remove parentheses to get clean element names: ["Coat", "Black 1"]
                    const cleanElements = elementsWithParens.map(p => p.slice(1, -1));
                    
                    // 2. The full path for the tree structure: ["Misc", "Coat", "Black 1"]
                    const path = [category, ...cleanElements];
                    
                    // 3. Store the original text with parentheses for other features like highlighting
                    const buttonData = {
                        fullButtonText: elementsWithParens.join(' ')
                    };
                    
                    // 4. Insert into the tree, checking for duplicates.
                    if (insertButtonIntoTree(customButtonTree, path, buttonData)) {
                        newButtonsCreated++;
                    }
                }
            }

            if (newButtonsCreated > 0) {
                projectData.customButtonTree = customButtonTree;
                saveProjectData(directoryName, projectData);
                await loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                alert(`${newButtonsCreated} new button(s) created successfully!`);
            } else {
                alert('No new buttons were found. They may already exist or not match the current Project Username.');
            }
            
            document.getElementById('cog-dropdown').style.display = 'none';
        });


        sortSelector.addEventListener('change', (e) => {
            const value = e.target.value;
            if (value) {
                sortThumbnails(value);
                e.target.value = ''; // Reset to placeholder
            }
        });

        saveLayoutBtn.addEventListener('click', saveLayout);
        loadLayoutBtn.addEventListener('click', loadLayout);
        multiSelectBtn.addEventListener('click', () => {
            isMultiSelectMode = !isMultiSelectMode;
            multiSelectBtn.classList.toggle('active', isMultiSelectMode);
        });

        deselectAllBtn.addEventListener('click', () => {
            selectedThumbnails.forEach(thumb => thumb.classList.remove('selected'));
            selectedThumbnails.clear();
            updatePlayButtonState();
            updateBottomBarInfo();
            updatePreviewPanel();
        });

        hideBtn.addEventListener('click', () => {
            if (hideBtn.textContent === 'Hide') {
                let hiddenCanvas = Array.from(canvases.values()).find(c => c.name === 'Hidden');
                if (!hiddenCanvas) {
                    const newCanvasId = getNextCanvasId();
                    hiddenCanvas = { id: newCanvasId, name: 'Hidden', thumbnails: [], settings: { thumbnailSize: '1' } };
                    canvases.set(newCanvasId, hiddenCanvas);
                }

                selectedThumbnails.forEach(thumb => {
                    thumb.dataset.previousCanvasId = activeCanvasId;
                });
                
                sendThumbnailsToCanvas(hiddenCanvas.id);
            } else { // Unhide
                const thumbnailsToUnhide = new Map();
                selectedThumbnails.forEach(thumb => {
                    const targetCanvasId = parseInt(thumb.dataset.previousCanvasId) || 1; // Default to canvas 1 if unset
                    if (!thumbnailsToUnhide.has(targetCanvasId)) {
                        thumbnailsToUnhide.set(targetCanvasId, []);
                    }
                    thumbnailsToUnhide.get(targetCanvasId).push(thumb);
                });

                const currentCanvas = canvases.get(activeCanvasId);
                thumbnailsToUnhide.forEach((thumbs, targetId) => {
                    const targetCanvas = canvases.get(targetId);
                    if (targetCanvas) {
                        thumbs.forEach(thumb => {
                            currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                            targetCanvas.thumbnails.push(thumb);
                            thumb.classList.remove('selected');
                        });
                    }
                });

                selectedThumbnails.clear();
                saveCanvasState();
                renderCanvas(activeCanvasId);
                updatePlayButtonState();
            }
        });

        deleteLayoutBtn.addEventListener('click', deleteLayout);
        splitBtn.addEventListener('click', () => {
            const newCanvasId = getNextCanvasId();
            const newCanvas = { id: newCanvasId, name: `Canvas ${newCanvasId}`, thumbnails: [], settings: { thumbnailSize: '1' } };
            canvases.set(newCanvasId, newCanvas);

            const currentCanvas = canvases.get(activeCanvasId);
            selectedThumbnails.forEach(thumb => {
                currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                newCanvas.thumbnails.push(thumb); // Positions are preserved
                thumb.classList.remove('selected');
            });

            selectedThumbnails.clear();
            updatePlayButtonState();
            saveCanvasState();
            
            populateCanvasDropdown();
            canvasSelect.value = newCanvasId;
            renderCanvas(newCanvasId);
        });
        canvasSelect.addEventListener('change', (e) => {
            const newCanvasId = parseInt(e.target.value);
            const renamedCanvas = Array.from(canvases.values()).find(c => c.name === 'Renamed');

            if (newCanvasId !== activeCanvasId) {
                if (renamedCanvas && newCanvasId === renamedCanvas.id) {
                    lastCanvasIdBeforeRenamed = activeCanvasId;
                } else {
                    lastCanvasIdBeforeRenamed = null; 
                }
                lastActiveCanvasId = activeCanvasId;
                document.getElementById('toggle-last-canvas-btn').style.display = 'inline-block';
            }
            renderCanvas(newCanvasId);
        });
        
        document.getElementById('toggle-renamed-canvas-btn').addEventListener('click', () => {
            const renamedCanvas = Array.from(canvases.values()).find(c => c.name === 'Renamed');
            if (!renamedCanvas) return;

            if (activeCanvasId === renamedCanvas.id) {
                // If we are on Renamed, go back to the last one
                if (lastCanvasIdBeforeRenamed && canvases.has(lastCanvasIdBeforeRenamed)) {
                    renderCanvas(lastCanvasIdBeforeRenamed);
                }
            } else {
                // If we are not on Renamed, go to it
                lastCanvasIdBeforeRenamed = activeCanvasId;
                renderCanvas(renamedCanvas.id);
            }
        });

        document.getElementById('toggle-last-canvas-btn').addEventListener('click', () => {
            if (lastActiveCanvasId) {
                const currentId = activeCanvasId;
                renderCanvas(lastActiveCanvasId);
                lastActiveCanvasId = currentId;
            }
        });

        sendToCanvasSelect.addEventListener('change', (e) => {
            const targetCanvasId = parseInt(e.target.value);
            if (!targetCanvasId) return;
            sendThumbnailsToCanvas(targetCanvasId);
            e.target.value = ''; // Reset dropdown
        });

        closeCanvasBtn.addEventListener('click', () => {
            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas && currentCanvas.thumbnails.length === 0 && canvases.size > 1) {
                canvases.delete(activeCanvasId);
                const newActiveCanvasId = canvases.keys().next().value;
                saveCanvasState();
                populateCanvasDropdown();
                canvasSelect.value = newActiveCanvasId;
                renderCanvas(newActiveCanvasId);
            }
        });

        function sendThumbnailsToCanvas(targetCanvasId, clearSelection = true) {
            const targetCanvas = canvases.get(targetCanvasId);
            if (!targetCanvas) return;

            const currentCanvas = canvases.get(activeCanvasId);

            selectedThumbnails.forEach(thumb => {
                currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                targetCanvas.thumbnails.push(thumb);
                if(clearSelection) {
                    thumb.classList.remove('selected');
                }
            });

            if (clearSelection) {
                selectedThumbnails.clear();
            }
            saveCanvasState();
            renderCanvas(activeCanvasId); // Re-render the current canvas to show the items have moved
            updatePlayButtonState();
        }

        playBtn.addEventListener('click', () => {
            const editModeBtn = document.getElementById('edit-mode-btn');
            const inEditMode = editModeBtn && editModeBtn.textContent.includes('On');

            if (inEditMode) {
                if (playSelections.size === 0) return;
                playlist = Array.from(playSelections).map(videoName => {
                    const videoFile = allVideoFiles.find(f => f.name.startsWith(videoName));
                    if (videoFile) {
                        return { dataset: { fileName: videoFile.name.replace(/\.[^/.]+$/, ".jpg") } };
                    }
                    return null;
                }).filter(Boolean);
            } else if (selectedThumbnails.size > 0) {
                playlist = Array.from(selectedThumbnails);
            } else if (buttonsForRemoval.size === 1) {
                const buttonId = buttonsForRemoval.values().next().value;
                const buttonElement = document.querySelector(`button[data-id='${buttonId}']`);
                if (buttonElement) {
                    const lastClickedData = JSON.parse(renameBtn.dataset.lastClicked || 'null');
                    if (lastClickedData) {
                        const { path, fullButtonText, specialType } = lastClickedData;
                        const isCategoryOnly = specialType === 'plusOne';

                        const username = projectUsernameInput.value.trim();
                        const category = path[0];
                        const prefix = `[${username}]_${category}`;

                        const currentCanvas = canvases.get(activeCanvasId);
                        if (currentCanvas) {
                            playlist = currentCanvas.thumbnails.filter(thumb => {
                                const baseFilename = thumb.dataset.fileName.substring(0, thumb.dataset.fileName.lastIndexOf('.'));
                                const filenameWithoutNumber = baseFilename.replace(/\s*\(\d+\)$/, '').trim();
                                
                                if (isCategoryOnly) {
                                    return filenameWithoutNumber === prefix;
                                } else {
                                    const expectedFilenamePart = `${prefix} ${fullButtonText}`;
                                    return filenameWithoutNumber.startsWith(expectedFilenamePart);
                                }
                            });
                        }
                    }
                }
            } else {
                 playlist = [];
            }


            if (playlist.length > 0) {
                const contentArea = document.getElementById('content-area');
                const rect = contentArea.getBoundingClientRect();
                videoOverlay.style.top = `${rect.top}px`;
                videoOverlay.style.left = `${rect.left}px`;
                videoOverlay.style.width = `${rect.width}px`;
                videoOverlay.style.height = `${rect.height}px`;
                videoOverlay.style.display = 'flex';
                loadVideo(0);
            }
        });

        document.getElementById('delete-selected-btn').addEventListener('click', () => {
            let deletedCanvas = Array.from(canvases.values()).find(c => c.name === 'Deleted');
            if (!deletedCanvas) {
                const newCanvasId = getNextCanvasId();
                deletedCanvas = { id: newCanvasId, name: 'Deleted', thumbnails: [], settings: { thumbnailSize: '1' } };
                canvases.set(newCanvasId, deletedCanvas);
            }

            selectedThumbnails.forEach(thumb => {
                thumb.dataset.previousCanvasId = activeCanvasId;
            });
            
            sendThumbnailsToCanvas(deletedCanvas.id);
        });
        videoCloseBtn.addEventListener('click', () => {
            videoOverlay.style.display = 'none';
            videoPlayer.pause();
            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
                currentVideoUrl = null;
            }
        });
        videoPrevBtn.addEventListener('click', () => {
            if (currentPlaylistIndex > 0) {
                loadVideo(currentPlaylistIndex - 1);
            }
        });
        videoNextBtn.addEventListener('click', () => {
            if (currentPlaylistIndex < playlist.length - 1) {
                loadVideo(currentPlaylistIndex + 1);
            }
        });

        thumbnailContainer.addEventListener('mousedown', startSelection);

        scriptModal.querySelector('.close').addEventListener('click', () => scriptModal.style.display = 'none');
        copyScriptBtn.addEventListener('click', copyScriptToClipboard);
        downloadScriptLink.addEventListener('click', downloadBatchFile);
        sizeSelector.addEventListener('change', (event) => {
            const newSize = event.target.value;
            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas) {
                if (!currentCanvas.settings) {
                    currentCanvas.settings = {};
                }
                currentCanvas.settings.thumbnailSize = newSize;
                saveCanvasState();
            }

            const editModeBtn = document.getElementById('edit-mode-btn');
            listViewButtonControls.style.display = newSize === 'list' ? 'flex' : 'none';
            if (editModeBtn && editModeBtn.textContent.includes('On')) {
                layoutLandscapeThumbnails();
            } else {
                if (newSize === 'list') {
                    layoutThumbnailsInList();
                } else {
                    layoutThumbnailsInGrid();
                }
            }
        });

        showThumbnailsBtn.addEventListener('click', () => {
            showThumbnailsBtn.classList.toggle('active');
            if (directoryName) {
                const projectData = loadProjectData(directoryName);
                projectData.listViewShowThumbnails = showThumbnailsBtn.classList.contains('active');
                saveProjectData(directoryName, projectData);
            }
            layoutThumbnailsInList();
        });
        showCanvasNameBtn.addEventListener('click', () => {
            showCanvasNameBtn.classList.toggle('active');
            if (directoryName) {
                const projectData = loadProjectData(directoryName);
                projectData.listViewShowCanvasName = showCanvasNameBtn.classList.contains('active');
                saveProjectData(directoryName, projectData);
            }
            layoutThumbnailsInList();
        });

        showOriginalFilenameBtn.addEventListener('click', () => {
            showOriginalFilenameBtn.classList.toggle('active');
            if (directoryName) {
                const projectData = loadProjectData(directoryName);
                projectData.listViewShowOriginalFilename = showOriginalFilenameBtn.classList.contains('active');
                saveProjectData(directoryName, projectData);
            }
            layoutThumbnailsInList();
        });


        function layoutThumbnailsInList() {
            thumbnailContainer.classList.add('list-view-active');
            isLayoutFrozen = false;
            const showThumbnails = showThumbnailsBtn.classList.contains('active');
            const showCanvasName = showCanvasNameBtn.classList.contains('active');
            const showOriginalFilename = showOriginalFilenameBtn.classList.contains('active');

            const wrappers = Array.from(thumbnailContainer.querySelectorAll('.thumbnail-wrapper'));
            
            // Always sort by the current (new) filename for consistency
            wrappers.sort((a, b) => {
                const nameA = a.dataset.fileName.toLowerCase();
                const nameB = b.dataset.fileName.toLowerCase();
                return nameA.localeCompare(nameB);
            });
            wrappers.forEach(wrapper => thumbnailContainer.appendChild(wrapper));

            wrappers.forEach(wrapper => {
                wrapper.style.position = 'relative';
                wrapper.style.left = '0px';
                wrapper.style.top = '0px';
                wrapper.classList.add('list-view');

                const thumb = wrapper.querySelector('.thumbnail');
                const nameDiv = wrapper.querySelector('.thumbnail-name');
                const canvasNamePlaceholder = wrapper.querySelector('.canvas-name-placeholder');
                const newFilenamePlaceholder = wrapper.querySelector('.new-filename-placeholder'); // This will now hold the original name
                
                const originalFilename = nameDiv.dataset.originalFilename;
                const newFilename = wrapper.dataset.fileName;
                const isRenamed = originalFilename !== newFilename;

                // Main display is always the new/current filename
                nameDiv.textContent = newFilename;

                // The placeholder column shows the original filename
                newFilenamePlaceholder.textContent = originalFilename;


                if (thumb) thumb.style.display = showThumbnails ? 'block' : 'none';
                if (canvasNamePlaceholder) canvasNamePlaceholder.style.display = showCanvasName ? 'block' : 'none';
                // The visibility of the original name is controlled by the "Show Original Name" button
                if (newFilenamePlaceholder) newFilenamePlaceholder.style.display = showOriginalFilename ? 'block' : 'none';
            });
            updateContentSpacer();
        }

        function layoutThumbnailsInGrid() {
            thumbnailContainer.classList.remove('list-view-active');
            thumbnailContainer.querySelectorAll('.thumbnail-wrapper').forEach(wrapper => {
                wrapper.classList.remove('list-view');

                // Reset inline display styles that may have been set by list view
                const thumb = wrapper.querySelector('.thumbnail');
                if (thumb) thumb.style.display = '';

                const nameDiv = wrapper.querySelector('.thumbnail-name');
                if (nameDiv) nameDiv.style.display = 'none';

                const canvasNamePlaceholder = wrapper.querySelector('.canvas-name-placeholder');
                if (canvasNamePlaceholder) canvasNamePlaceholder.style.display = '';

                const newFilenamePlaceholder = wrapper.querySelector('.new-filename-placeholder');
                if (newFilenamePlaceholder) newFilenamePlaceholder.style.display = '';
            });

            if (isLayoutFrozen) {
                const scale = parseFloat(sizeSelector.value);
                thumbnailContainer.querySelectorAll('.thumbnail-wrapper').forEach(wrapper => {
                    const thumb = wrapper.querySelector('.thumbnail');
                    const nameDiv = wrapper.querySelector('.thumbnail-name');
                    const originalWidth = thumb.dataset.originalWidth;
                    if (originalWidth) {
                        const scaledWidth = originalWidth * scale;
                        thumb.style.width = scaledWidth + 'px';
                        thumb.style.height = 'auto';
                        nameDiv.style.maxWidth = scaledWidth + 'px';
                    }
                });
                updateContentSpacer();
                return;
            }

            const projectData = loadProjectData(directoryName);
            const verticalPadding = Number(projectData.verticalPadding) || 0;
            const horizontalPadding = Number(projectData.horizontalPadding) || 0;
            const scale = parseFloat(sizeSelector.value);
            const containerWidth = thumbnailContainer.clientWidth;
            let xOffset = horizontalPadding;
            let yOffset = verticalPadding;
            let maxRowHeight = 0;

            const wrappers = thumbnailContainer.querySelectorAll('.thumbnail-wrapper');

            wrappers.forEach(wrapper => {
                const thumb = wrapper.querySelector('.thumbnail');
                const nameDiv = wrapper.querySelector('.thumbnail-name');
                
                // Temporarily make the name visible to get its height for layout calculation
                const originalDisplay = nameDiv.style.display;
                nameDiv.style.display = 'block';

                const originalWidth = parseFloat(thumb.dataset.originalWidth);
                const originalHeight = parseFloat(thumb.dataset.originalHeight);
                
                const scaledWidth = originalWidth * scale;
                const scaledHeight = originalHeight * scale;

                nameDiv.style.maxWidth = scaledWidth + 'px';
                const nameHeight = nameDiv.offsetHeight;
                
                // Restore the original display property
                nameDiv.style.display = originalDisplay;

                const wrapperHeight = wrapper.offsetHeight;

                if (xOffset + scaledWidth + horizontalPadding > containerWidth && xOffset > horizontalPadding) {
                    xOffset = horizontalPadding;
                    yOffset += maxRowHeight + verticalPadding;
                    maxRowHeight = 0;
                }
                
                wrapper.style.position = 'absolute';
                wrapper.style.left = xOffset + 'px';
                wrapper.style.top = yOffset + 'px';
                thumb.style.width = scaledWidth + 'px';
                thumb.style.height = scaledHeight + 'px';

                if (wrapperHeight > maxRowHeight) {
                    maxRowHeight = wrapperHeight;
                }
                
                xOffset += scaledWidth + horizontalPadding;
            });

            updateContentSpacer();
        }

        async function processDirectory(dirHandle) {
            // --- Clear previous state ---
            thumbnailContainer.innerHTML = ''; // Clear thumbnails
            document.getElementById('sidebar-scroll-container').innerHTML = ''; // Clear buttons
            canvases.clear();
            allThumbnails = [];
            isLayoutFrozen = false;
            document.getElementById('edit-mode-options').style.display = 'none';


            currentDirHandle = dirHandle;
            await setDb('lastDirectory', dirHandle);
            
            let recentDirs = await getDb('recentDirectories') || [];
            const existingIndex = recentDirs.findIndex(dir => dir.name === dirHandle.name);
            if (existingIndex > -1) {
                recentDirs.splice(existingIndex, 1);
            }
            recentDirs.unshift({name: dirHandle.name, handle: dirHandle});
            if (recentDirs.length > 5) {
                recentDirs = recentDirs.slice(0, 5);
            }
            await setDb('recentDirectories', recentDirs);
            await loadRecentDirectories();

            directoryName = dirHandle.name;
            document.title = directoryName; // Update page title
            
            initializeUI(); // Initialize UI with the correct directoryName

            const projectData = loadProjectData(directoryName);

            projectUsernameInput.value = projectData.projectUsername;
            document.getElementById('num-elements-input').value = projectData.numElements;
            document.getElementById('font-size-slider').value = projectData.fontSize;
            document.getElementById('vertical-padding-input').value = projectData.verticalPadding;
            document.getElementById('horizontal-padding-input').value = projectData.horizontalPadding;
            document.getElementById('preview-vertical-padding-input').value = projectData.previewVerticalPadding;

            // --- Restore Preview Sidebar State ---
            const previewSizeSelector = document.getElementById('preview-size-selector');
            if (projectData.previewSidebarVisible) {
                rightSidebar.style.display = 'flex';
                rightSidebar.style.width = `${projectData.previewSidebarWidth}px`;
            } else {
                rightSidebar.style.display = 'none';
            }
            previewSizeSelector.value = projectData.previewThumbnailSize || '0.5';

            // --- Restore List View Toggle State ---
            showThumbnailsBtn.classList.toggle('active', projectData.listViewShowThumbnails);
            showCanvasNameBtn.classList.toggle('active', projectData.listViewShowCanvasName);
            showOriginalFilenameBtn.classList.toggle('active', projectData.listViewShowOriginalFilename);

            loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);

            try {
                let hasEditThumbnails = false;
            let hasLandscapeVideos = false;
            let hasLandscapeRotateVideos = false;
            let hasEditVideos = false;

            try {
                await dirHandle.getDirectoryHandle('Edit Thumbnails');
                hasEditThumbnails = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }

            try {
                await dirHandle.getDirectoryHandle('Landscape');
                hasLandscapeVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }
            
            try {
                await dirHandle.getDirectoryHandle('Landscape Rotate');
                hasLandscapeRotateVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }
            
            try {
                await dirHandle.getDirectoryHandle('Edit');
                hasEditVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }


            if (hasEditThumbnails) {
                const editModeOptions = document.getElementById('edit-mode-options');
                const editModeBtn = document.getElementById('edit-mode-btn');
                const generateBatBtn = document.getElementById('generate-edit-bat-btn');

                editModeOptions.style.display = 'block';
                
                // Reset state for the new directory
                editModeBtn.textContent = 'Edit Mode Off';
                generateBatBtn.style.display = 'none';
                document.getElementById('landscape-buttons').style.display = 'none';
                
                // --- Attach listeners only once ---
                if (!editModeBtn.dataset.listenerAttached) {
                    editModeBtn.dataset.listenerAttached = 'true';
                    generateBatBtn.dataset.listenerAttached = 'true';

                    editModeBtn.addEventListener('click', () => {
                        const listOption = sizeSelector.querySelector('option[value="list"]');
                        if (editModeBtn.textContent.includes('Off')) {
                            // Before entering edit mode, save the current canvas for each thumbnail
                            preEditModeCanvasMap.clear();
                            for (const [canvasId, canvas] of canvases.entries()) {
                                canvas.thumbnails.forEach(thumbWrapper => {
                                    preEditModeCanvasMap.set(thumbWrapper.dataset.fileName, canvasId);
                                });
                            }
                            const projectData = loadProjectData(directoryName);
                            projectData.preEditModeCanvasMap = Object.fromEntries(preEditModeCanvasMap);
                            saveProjectData(directoryName, projectData);


                            renderEditMode();
                            generateBatBtn.style.display = 'block';
                            editModeBtn.textContent = 'Edit Mode On';
                            if (sizeSelector.value === 'list') {
                                sizeSelector.value = '1';
                                layoutThumbnailsInGrid();
                            }
                            listOption.disabled = true;
                        } else {
                            document.getElementById('landscape-buttons').style.display = 'none';
                            generateBatBtn.style.display = 'none';
                            editModeBtn.textContent = 'Edit Mode Off';
                            listOption.disabled = false;
                            isLayoutFrozen = false; 

                            // Force-reset all thumbnail positions before re-rendering
                            const currentCanvas = canvases.get(activeCanvasId);
                            if (currentCanvas) {
                                currentCanvas.thumbnails.forEach(thumb => {
                                    thumb.style.position = '';
                                    thumb.style.left = '';
                                    thumb.style.top = '';
                                });
                            }

                            renderCanvas(activeCanvasId);
                        }
                    });

                    generateBatBtn.addEventListener('click', () => {
                        generateFinalBatchScript();
                        document.getElementById('final-landscape-script-modal').style.display = 'block';
                    });
                }
            }

            isLayoutFrozen = false;
            selectedThumbnails.clear();
            updatePlayButtonState();
            
            allVideoFiles = [];
            let thumbnailFiles = [];
            let hasThumbnailsSubdir = false;
            const thumbnailsToUpdate = new Set();

            async function recursivelyFindThumbnails(dirHandle, pathPrefix = '') {
                const thumbnailsDirHandle = await dirHandle.getDirectoryHandle('Thumbnails');
                for await (const entry of thumbnailsDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.match(/\.(jpe?g|png|gif|webp)$/i)) {
                        thumbnailFiles.push(await entry.getFile());
                    }
                }
            }

            scanLayouts = {}; // Reset scan layouts
            try {
                const scanDirHandle = await dirHandle.getDirectoryHandle('scan');
                for await (const entry of scanDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.json')) {
                        const file = await entry.getFile();
                        const text = await file.text();
                        try {
                            const layoutName = entry.name.replace('.json', '');
                            scanLayouts[layoutName] = JSON.parse(text);
                        } catch (e) {
                            console.error(`Error parsing ${entry.name}:`, e);
                        }
                    }
                }
            } catch (e) {
                // scan directory doesn't exist, which is fine.
            }

            async function recursivelyFindVideos(dirHandle, pathPrefix = '') {
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.match(/\.(mp4|avi|mov|mkv)$/i)) {
                        const file = await entry.getFile();
                        file.customPath = pathPrefix; // Store the subdirectory
                        allVideoFiles.push(file);
                    }
                }
            }

            // Find videos in the root and other key directories
            await recursivelyFindVideos(dirHandle, '');
            for (const subDir of ['Landscape', 'Landscape Rotate', 'Edit']) {
                try {
                    const subDirHandle = await dirHandle.getDirectoryHandle(subDir);
                    await recursivelyFindVideos(subDirHandle, subDir);
                } catch (e) {
                    // Subdirectory doesn't exist, which is fine.
                }
            }

            // Find thumbnails in the root and other key directories
            try {
                await recursivelyFindThumbnails(dirHandle);
                hasThumbnailsSubdir = true;
            } catch (e) {
                // Root 'Thumbnails' dir may not exist if all files were moved.
            }

            for (const subDir of ['Landscape', 'Landscape Rotate', 'Edit']) {
                try {
                    const subDirHandle = await dirHandle.getDirectoryHandle(subDir);
                    await recursivelyFindThumbnails(subDirHandle, subDir);
                    hasThumbnailsSubdir = true; // Found thumbnails in a subdir.
                } catch (e) {
                    // Subdirectory or its Thumbnails folder doesn't exist, which is fine.
                }
            }

            // --- Thumbnail Management Prompts ---
            const videoBasenames = new Set(allVideoFiles.map(f => f.name.substring(0, f.name.lastIndexOf('.'))));
            const thumbnailBasenames = new Set(thumbnailFiles.map(f => f.name.substring(0, f.name.lastIndexOf('.'))));

            const videosMissingThumbnails = allVideoFiles.filter(f => !thumbnailBasenames.has(f.name.substring(0, f.name.lastIndexOf('.'))));
            let orphanedThumbnails = thumbnailFiles.filter(f => !videoBasenames.has(f.name.substring(0, f.name.lastIndexOf('.'))));

            // Filter out thumbnails that are already permanently hidden
            const permanentlyHidden = new Set(projectData.hiddenOrphans || []);
            const newlyOrphaned = orphanedThumbnails.filter(f => !permanentlyHidden.has(f.name));

            if (newlyOrphaned.length > 0) {
                const userChoice = await promptOrphanedThumbnails(newlyOrphaned);
                const orphanNamesToHide = new Set(newlyOrphaned.map(f => f.name));
                
                if (userChoice === 'hide') {
                    thumbnailFiles = thumbnailFiles.filter(f => !orphanNamesToHide.has(f.name));
                } else if (userChoice === 'delete') {
                    generateOrphanDeletionScript(newlyOrphaned);
                } else if (userChoice === 'hideForever') {
                    projectData.hiddenOrphans = [...permanentlyHidden, ...orphanNamesToHide];
                    saveProjectData(directoryName, projectData);
                    thumbnailFiles = thumbnailFiles.filter(f => !orphanNamesToHide.has(f.name));
                }
            }
            
            // Always filter out the permanently hidden ones from the main list
            thumbnailFiles = thumbnailFiles.filter(f => !permanentlyHidden.has(f.name));
            
            if (videosMissingThumbnails.length > 0) {
                if (confirm(`${videosMissingThumbnails.length} video(s) are missing thumbnails. Would you like to generate a script to create them?`)) {
                    generateBatchScript(videosMissingThumbnails, directoryName);
                    scriptModal.style.display = 'block';
                }
            }
            
            if (hasThumbnailsSubdir) {
                const savedCanvasData = projectData.canvases;

                allThumbnails = [];
                canvases.clear();
                
                const imageLoadPromises = thumbnailFiles.map(file => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            img.dataset.originalWidth = img.width;
                            img.dataset.originalHeight = img.height;
                            resolve(img);
                        };
                        img.onerror = reject;
                        img.classList.add('thumbnail');
                        img.draggable = false;
                        img.dataset.fileName = file.name;
                        img.src = URL.createObjectURL(file);
                    });
                });

                const loadedImages = await Promise.all(imageLoadPromises);

                const wrapperMap = new Map();
                loadedImages.forEach(img => {
                    const wrapper = document.createElement('div');
                    wrapper.classList.add('thumbnail-wrapper');
                    wrapper.dataset.fileName = img.dataset.fileName;
                    wrapper.appendChild(img);

                    const nameDiv = document.createElement('div');
                    nameDiv.classList.add('thumbnail-name');
                    nameDiv.textContent = img.dataset.fileName;
                    nameDiv.dataset.originalFilename = img.dataset.fileName;
                    wrapper.appendChild(nameDiv);

                    const newFilenameDiv = document.createElement('div');
                    newFilenameDiv.classList.add('new-filename-placeholder');
                    newFilenameDiv.textContent = '...'; // Placeholder text
                    wrapper.appendChild(newFilenameDiv);

                    const canvasNameDiv = document.createElement('div');
                    canvasNameDiv.classList.add('canvas-name-placeholder');
                    wrapper.appendChild(canvasNameDiv);


                    wrapperMap.set(img.dataset.fileName, wrapper);

                    makeDraggable(wrapper);
                    
                    nameDiv.addEventListener('dblclick', () => {
                        nameDiv.contentEditable = true;
                        nameDiv.focus();
                    });

                    nameDiv.addEventListener('blur', () => {
                        nameDiv.contentEditable = false;
                        const newName = nameDiv.textContent;
                        img.dataset.fileName = newName;
                        wrapper.dataset.fileName = newName;
                        saveCanvasState();
                    });
                });

                try {
                    if (!savedCanvasData || !Array.isArray(savedCanvasData.canvases)) throw new Error("No valid saved data");

                    canvases = new Map(savedCanvasData.canvases.map(c => [c.id, { ...c, thumbnails: [] }]));
                    activeCanvasId = savedCanvasData.activeCanvasId;
                    const placedThumbnails = new Set();

                    savedCanvasData.canvases.forEach(savedCanvas => {
                        const canvas = canvases.get(savedCanvas.id);
                        if (!canvas) return;
                        savedCanvas.thumbnails.forEach(savedThumb => {
                            const wrapper = wrapperMap.get(savedThumb.originalFilename);
                            if (wrapper) {
                                // Restore both original and current names
                                wrapper.dataset.fileName = savedThumb.fileName;
                                const img = wrapper.querySelector('.thumbnail');
                                if (img) img.dataset.fileName = savedThumb.fileName;
                                const nameDiv = wrapper.querySelector('.thumbnail-name');
                                if (nameDiv) {
                                    nameDiv.textContent = savedThumb.fileName;
                                    nameDiv.dataset.originalFilename = savedThumb.originalFilename;
                                }
                                 const newFilenamePlaceholder = wrapper.querySelector('.new-filename-placeholder');
                                if (newFilenamePlaceholder && savedThumb.fileName !== savedThumb.originalFilename) {
                                    newFilenamePlaceholder.textContent = savedThumb.fileName;
                                }


                                canvas.thumbnails.push(wrapper);
                                wrapper.style.position = 'absolute';
                                wrapper.style.left = savedThumb.left;
                                wrapper.style.top = savedThumb.top;
                                if (savedThumb.previousCanvasId) {
                                    wrapper.dataset.previousCanvasId = savedThumb.previousCanvasId;
                                }
                                placedThumbnails.add(savedThumb.originalFilename);
                                isLayoutFrozen = true;
                            }
                        });
                    });
                    
                    // Add any newly found thumbnails (not in save data) to the first canvas
                    const defaultCanvas = canvases.get(canvases.keys().next().value || 1);
                    if(defaultCanvas) {
                        for (const [fileName, wrapper] of wrapperMap.entries()) {
                            if (!placedThumbnails.has(fileName)) {
                                defaultCanvas.thumbnails.push(wrapper);
                            }
                        }
                    }

                    if (!canvases.has(activeCanvasId)) {
                        activeCanvasId = canvases.keys().next().value || 1;
                    }

                } catch (err) {
                    console.warn("Could not restore canvas from saved data. Loading fresh.", err);
                    projectData.canvases = null;
                    saveProjectData(directoryName, projectData);
                    canvases.clear();
                    canvases.set(1, { id: 1, name: 'Canvas 1', thumbnails: Array.from(wrapperMap.values()), settings: { thumbnailSize: '1' } });
                    activeCanvasId = 1;
                    isLayoutFrozen = false;
                }

                if (!Array.from(canvases.values()).find(c => c.name === 'Renamed')) {
                    const renamedCanvasId = getNextCanvasId();
                    canvases.set(renamedCanvasId, { id: renamedCanvasId, name: 'Renamed', thumbnails: [], settings: { thumbnailSize: '1' } });
                }
                
                if (projectData.preEditModeCanvasMap) {
                    const restoreThumbnailsFromPreEditMap = () => {
                        const preEditMap = new Map(Object.entries(projectData.preEditModeCanvasMap));
                        
                        const allLoadedThumbsMap = new Map();
                        for (const canvas of canvases.values()) {
                            for (const thumb of canvas.thumbnails) {
                                if (!allLoadedThumbsMap.has(thumb.dataset.fileName)) {
                                    allLoadedThumbsMap.set(thumb.dataset.fileName, thumb);
                                }
                            }
                        }

                        for (const canvas of canvases.values()) {
                            canvas.thumbnails = [];
                        }

                        for (const [fileName, canvasId] of preEditMap.entries()) {
                            const thumb = allLoadedThumbsMap.get(fileName);
                            if (thumb) {
                                const targetCanvas = canvases.get(parseInt(canvasId));
                                if (targetCanvas) {
                                    targetCanvas.thumbnails.push(thumb);
                                    const canvasNamePlaceholder = thumb.querySelector('.canvas-name-placeholder');
                                    if (canvasNamePlaceholder) {
                                        canvasNamePlaceholder.textContent = targetCanvas.name;
                                    }
                                } else {
                                    canvases.get(1)?.thumbnails.push(thumb);
                                }
                                allLoadedThumbsMap.delete(fileName);
                            }
                        }

                        const defaultCanvas = canvases.get(1);
                        if (defaultCanvas) {
                            for (const thumb of allLoadedThumbsMap.values()) {
                                defaultCanvas.thumbnails.push(thumb);
                            }
                        }

                        delete projectData.preEditModeCanvasMap;
                        saveProjectData(directoryName, projectData);
                    };
                    restoreThumbnailsFromPreEditMap();
                }

                populateCanvasDropdown();
                renderCanvas(activeCanvasId);

            } else if (allVideoFiles.length > 0) {
                generateBatchScript(allVideoFiles, directoryName);
                scriptModal.style.display = 'block';
            }
            } catch (err) {
                console.error("A critical error occurred while processing the directory:", err);
                alert("An unexpected error occurred while trying to read the directory contents. Please try loading the directory again.");
            } finally {
                populateLayoutsDropdown();
            }
        }

        async function loadRecentDirectories() {
            const recentDirs = await getDb('recentDirectories') || [];
            const list = document.getElementById('recent-directories-list');
            list.innerHTML = '';

            if (recentDirs.length > 0) {
                for (const dir of recentDirs) {
                    const a = document.createElement('a');
                    a.href = '#';
                    a.textContent = dir.name;
                    a.title = dir.name;
                    a.addEventListener('click', async (e) => {
                        e.preventDefault();
                        // --- Validate handle before use ---
                        if (!dir.handle || typeof dir.handle.queryPermission !== 'function') {
                            alert('This directory reference is stale. Please re-select it using "Load Directory".');
                            await removeDirectory(dir.name);
                            return;
                        }

                        try {
                            const hasPermission = await dir.handle.queryPermission({ mode: 'read' }) === 'granted' ||
                                                  await dir.handle.requestPermission({ mode: 'read' }) === 'granted';
                            if (hasPermission) {
                                await processDirectory(dir.handle);
                                document.getElementById('cog-dropdown').style.display = 'none'; // Close menu after loading
                            }
                        } catch(e) {
                            alert('Could not access directory. It may have been moved, deleted, or permissions were denied.');
                            await removeDirectory(dir.name);
                        }
                    });
                    list.appendChild(a);
                }
            } else {
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = 'No recent directories';
                a.style.pointerEvents = 'none';
                list.appendChild(a);
            }
        }

        async function removeDirectory(dirName) {
            let recentDirs = await getDb('recentDirectories') || [];
            recentDirs = recentDirs.filter(d => d.name !== dirName);
            await setDb('recentDirectories', recentDirs);
            await loadRecentDirectories();
        }

        async function renderEditMode() {
            thumbnailContainer.innerHTML = ''; // Clear container for a clean slate
            document.getElementById('landscape-buttons').style.display = 'flex'; // Ensure buttons are visible

            const editDirHandle = await currentDirHandle.getDirectoryHandle('Edit Thumbnails');
            let landscapeFiles = [];
            for await (const entry of editDirHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/\.(jpe?g|png|gif|webp)$/i)) {
                    landscapeFiles.push(await entry.getFile());
                }
            }

            const videosToConsider = allVideoFiles.filter(f => f.customPath === '' || f.customPath === 'Landscape' || f.customPath === 'Landscape Rotate');
            const editThumbBasenames = new Set(landscapeFiles.map(f => f.name.substring(0, f.name.lastIndexOf('_'))));
            const videosMissingThumbs = videosToConsider.filter(vf => !editThumbBasenames.has(vf.name.substring(0, vf.name.lastIndexOf('.'))));

            if (videosMissingThumbs.length > 0) {
                if (confirm(`${videosMissingThumbs.length} video(s) are missing thumbnails in the 'Edit Thumbnails' directory. Would you like to generate a script to create them?`)) {
                    generateEditBatchScript(videosMissingThumbs);
                    editScriptModal.style.display = 'block';
                    return; // Stop further rendering until the user handles the script.
                }
            }

            const groupedFiles = landscapeFiles.reduce((acc, file) => {
                const videoName = file.name.substring(0, file.name.lastIndexOf('_'));
                if (!acc[videoName]) {
                    acc[videoName] = [];
                }
                acc[videoName].push(file);
                return acc;
            }, {});

            const videoNames = Object.keys(groupedFiles).sort();
            const allPromises = [];

            for (const videoName of videoNames) {
                const files = groupedFiles[videoName];
                files.sort((a, b) => {
                    const aNum = parseInt(a.name.substring(a.name.lastIndexOf('_') + 1));
                    const bNum = parseInt(b.name.substring(b.name.lastIndexOf('_') + 1));
                    return aNum - bNum;
                });

                const rowDiv = document.createElement('div');
                rowDiv.classList.add('landscape-row');
                rowDiv.dataset.videoName = videoName;
                thumbnailContainer.appendChild(rowDiv);

                rowDiv.addEventListener('click', () => {
                    const selections = {
                        'landscape': landscapeSelections,
                        'landscape-rotate': landscapeRotateSelections,
                        'delete': deleteSelections,
                        'edit': editSelections,
                        'shortcut': shortcutSelections,
                        'play': playSelections
                    };

                    if (!landscapeSelectionMode) {
                        alert('Please select a mode from the bottom bar first.');
                        return;
                    }

                    // Toggle selection for the current mode
                    if (selections[landscapeSelectionMode].has(videoName)) {
                        selections[landscapeSelectionMode].delete(videoName);
                    } else {
                        selections[landscapeSelectionMode].add(videoName);
                        // Ensure mutual exclusivity
                        for (const mode in selections) {
                            if (mode !== landscapeSelectionMode) {
                                selections[mode].delete(videoName);
                            }
                        }
                    }

                    // Update UI classes
                    rowDiv.classList.toggle('selected-landscape', landscapeSelections.has(videoName));
                    rowDiv.classList.toggle('selected-landscape-rotate', landscapeRotateSelections.has(videoName));
                    rowDiv.classList.toggle('selected-delete', deleteSelections.has(videoName));
                    rowDiv.classList.toggle('selected-edit', editSelections.has(videoName));
                    rowDiv.classList.toggle('selected-shortcut', shortcutSelections.has(videoName));
                    rowDiv.classList.toggle('selected-play', playSelections.has(videoName));
                    updatePlayButtonState();
                });

                 // Re-apply selection classes on initial render
                if (landscapeSelections.has(videoName)) rowDiv.classList.add('selected-landscape');
                if (landscapeRotateSelections.has(videoName)) rowDiv.classList.add('selected-landscape-rotate');
                if (deleteSelections.has(videoName)) rowDiv.classList.add('selected-delete');
                if (editSelections.has(videoName)) rowDiv.classList.add('selected-edit');
                if (shortcutSelections.has(videoName)) rowDiv.classList.add('selected-shortcut');
                if (playSelections.has(videoName)) rowDiv.classList.add('selected-play');

                const imageLoadPromises = files.map(file => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            img.classList.add('thumbnail');
                            img.dataset.fileName = file.name;
                            img.dataset.originalWidth = img.width;
                            img.dataset.originalHeight = img.height;
                            rowDiv.appendChild(img);
                            resolve(img);
                        };
                        img.onerror = reject;
                        img.src = URL.createObjectURL(file);
                    });
                });
                allPromises.push(Promise.all(imageLoadPromises));
            }

            await Promise.all(allPromises);
            layoutLandscapeThumbnails(); // Position and size after all images are loaded
        }

        function layoutLandscapeThumbnails() {
            const scale = parseFloat(sizeSelector.value);
            let yOffset = 20;
            const rows = document.querySelectorAll('.landscape-row');

            rows.forEach(row => {
                row.style.position = 'absolute';
                row.style.top = yOffset + 'px';
                let xOffset = 20;
                let maxRowHeight = 0;
                let totalRowWidth = 0;
                const thumbnails = row.querySelectorAll('.thumbnail');
                
                thumbnails.forEach((thumb, index) => {
                    const originalWidth = parseFloat(thumb.dataset.originalWidth);
                    const originalHeight = parseFloat(thumb.dataset.originalHeight);
                    
                    const scaledWidth = originalWidth * scale;
                    const scaledHeight = originalHeight * scale;

                    thumb.style.position = 'absolute';
                    thumb.style.width = scaledWidth + 'px';
                    thumb.style.height = scaledHeight + 'px';
                    thumb.style.left = xOffset + 'px';
                    thumb.style.top = '0px'; // Position relative to the row

                    xOffset += scaledWidth + 20;
                    if (scaledHeight > maxRowHeight) {
                        maxRowHeight = scaledHeight;
                    }
                });

                if (thumbnails.length > 0) {
                    totalRowWidth = xOffset;
                    row.style.width = totalRowWidth + 'px';
                    row.style.height = maxRowHeight + 'px';
                    yOffset += maxRowHeight + 20;
                }
            });
             updateContentSpacer();
        }

        function generateEditBatchScript(videoFiles) {
            const scriptLines = [
                '@echo off',
                'setlocal enabledelayedexpansion',
                'cd /d "%~dp0"',
                'echo Creating Edit Thumbnails directory...',
                'if not exist "Edit Thumbnails" mkdir "Edit Thumbnails"',
                'echo Generating edit thumbnails and updating tracking file...',
                '> processed_edit_mode_videos.txt (',
                ...videoFiles.map(file => `    echo "${file.name}"`),
                ')',
                '',
                ...videoFiles.flatMap(file => {
                    const fileName = file.name;
                    const baseName = fileName.substring(0, fileName.lastIndexOf('.'));
                    return [
                        '',
                        `echo Processing "${fileName}"...`,
                        `for /f "delims=" %%a in ('ffprobe -v error -show_entries format^=duration -of default^=noprint_wrappers^=1:nokey^=1 "${fileName}"') do (`,
                        '    set "duration_str=%%a"',
                        ')',
                        'for /f "delims=." %%a in ("!duration_str!") do set "duration_int=%%a"',
                        'if !duration_int! equ 0 set "duration_int=10"', // Avoid division by zero for very short videos
                        'set /a "interval = !duration_int! / 10"',
                        'if !interval! equ 0 set "interval=1"', // Ensure at least 1s interval for very short videos
                        'for /l %%i in (1, 1, 10) do (',
                        '    set /a "timestamp = (%%i - 1) * !interval!"',
                        `    echo   - Generating thumbnail %%i for "${fileName}" at !timestamp!s...`,
                        `    ffmpeg -ss !timestamp! -i "${fileName}" -vframes 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" -y "Edit Thumbnails\\${baseName}_%%i.jpg" >nul 2>&1 || echo Failed to generate thumbnail %%i for "${fileName}"`,
                        ')'
                    ];
                }),
                'echo.',
                'echo Thumbnail generation complete.',
                'pause'
            ];
            const script = scriptLines.join('\r\n');
            document.getElementById('edit-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-edit-script-link').href = URL.createObjectURL(blob);
        }

        function generateFinalBatchScript() {
            const scriptLines = [
                '# PowerShell Script to process video selections',
                'Write-Host "Creating output directories..."',
                'if (-not (Test-Path -LiteralPath "Landscape")) { New-Item -ItemType Directory -Path "Landscape" }',
                'if (-not (Test-Path -LiteralPath "Landscape\\Thumbnails")) { New-Item -ItemType Directory -Path "Landscape\\Thumbnails" }',
                'if (-not (Test-Path -LiteralPath "Landscape Rotate")) { New-Item -ItemType Directory -Path "Landscape Rotate" }',
                'if (-not (Test-Path -LiteralPath "Landscape Rotate\\Thumbnails")) { New-Item -ItemType Directory -Path "Landscape Rotate\\Thumbnails" }',
                'if (-not (Test-Path -LiteralPath "Edit")) { New-Item -ItemType Directory -Path "Edit" }',
                'if (-not (Test-Path -LiteralPath "Edit\\Thumbnails")) { New-Item -ItemType Directory -Path "Edit\\Thumbnails" }',
                ''
            ];

            const escapeString = (str) => `'${str.replace(/'/g, "''")}'`;

            const processRenamingAndThumbnails = (videoName, action, destination = '') => {
                const wrapper = Array.from(document.querySelectorAll('.thumbnail-wrapper')).find(w => {
                    const nameDiv = w.querySelector('.thumbnail-name');
                    return nameDiv && nameDiv.dataset.originalFilename.startsWith(videoName);
                });
                
                let originalVideoFile = allVideoFiles.find(f => f.name.startsWith(videoName));
                if (!originalVideoFile) return;

                let currentVideoName = originalVideoFile.name;
                const originalThumbName = originalVideoFile.name.replace(/\.[^/.]+$/, ".jpg");

                if (wrapper) {
                    const nameDiv = wrapper.querySelector('.thumbnail-name');
                    const img = wrapper.querySelector('.thumbnail');
                    const originalFilenameAttr = nameDiv.dataset.originalFilename;
                    const currentFilenameAttr = img.dataset.fileName;

                    if (originalFilenameAttr !== currentFilenameAttr) {
                        const newVideoName = currentFilenameAttr.replace(/\.jpg$/, '.mp4');
                        scriptLines.push(`Rename-Item -LiteralPath ${escapeString(currentVideoName)} -NewName ${escapeString(newVideoName)}`);
                        currentVideoName = newVideoName;
                    }
                }
                
                const currentThumbName = currentVideoName.replace(/\.[^/.]+$/, ".jpg");

                switch (action) {
                    case 'move':
                        scriptLines.push(`Move-Item -LiteralPath ${escapeString(currentVideoName)} -Destination ${escapeString(destination)}`);
                        scriptLines.push(`if (Test-Path -LiteralPath "Thumbnails\\${originalThumbName}") { Move-Item -LiteralPath "Thumbnails\\${originalThumbName}" -Destination "${destination}\\Thumbnails\\${currentThumbName}" }`);
                        break;
                    case 'rotate':
                        scriptLines.push(`ffmpeg -i ${escapeString(currentVideoName)} -vf "transpose=1" ${escapeString(destination + '\\' + currentVideoName)}`);
                        scriptLines.push(`Remove-Item -LiteralPath ${escapeString(currentVideoName)}`); // Sends to Recycle Bin
                        scriptLines.push(`if (Test-Path -LiteralPath "Thumbnails\\${originalThumbName}") { Move-Item -LiteralPath "Thumbnails\\${originalThumbName}" -Destination "${destination}\\Thumbnails\\${currentThumbName}" }`);
                        break;
                    case 'delete':
                        scriptLines.push(`Remove-Item -LiteralPath ${escapeString(currentVideoName)}`); // Sends to Recycle Bin
                        scriptLines.push(`if (Test-Path -LiteralPath "Thumbnails\\${originalThumbName}") { Remove-Item -LiteralPath "Thumbnails\\${originalThumbName}" }`);
                        break;
                }
            };

            if (landscapeSelections.size > 0) {
                scriptLines.push('Write-Host "Moving landscape files..."');
                landscapeSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'move', 'Landscape'));
                scriptLines.push('');
            }

            if (landscapeRotateSelections.size > 0) {
                scriptLines.push('Write-Host "Processing landscape rotate files..."');
                landscapeRotateSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'move', 'Landscape Rotate'));
                scriptLines.push('');
            }

            if (deleteSelections.size > 0) {
                scriptLines.push('Write-Host "Deleting selected files (to Recycle Bin)..."');
                deleteSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'delete'));
                scriptLines.push('');
            }

            if (editSelections.size > 0) {
                scriptLines.push('Write-Host "Moving files to Edit folder..."');
                editSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'move', 'Edit'));
                scriptLines.push('');
            }

            if (shortcutSelections.size > 0) {
                scriptLines.push('Write-Host "Creating shortcuts..."');
                scriptLines.push('if (-not (Test-Path -LiteralPath "sc")) { New-Item -ItemType Directory -Path "sc" }');
                scriptLines.push('$wshell = New-Object -ComObject WScript.Shell');
                shortcutSelections.forEach(videoName => {
                    const videoFile = allVideoFiles.find(f => f.name.startsWith(videoName));
                    if (videoFile) {
                        const targetPath = videoFile.customPath ? `${videoFile.customPath}\\${videoFile.name}` : videoFile.name;
                        const shortcutPath = `$PSScriptRoot\\sc\\${videoFile.name}.lnk`;
                        scriptLines.push(`$shortcut = $wshell.CreateShortcut("${shortcutPath}")`);
                        scriptLines.push(`$shortcut.TargetPath = Join-Path -Path $PSScriptRoot -ChildPath '${targetPath}'`);
                        scriptLines.push(`$shortcut.Save()`);
                    }
                });
                scriptLines.push('');
            }
            
            
            scriptLines.push('Write-Host "Processing complete."');
            scriptLines.push('Read-Host -Prompt "Press Enter to exit"');

            const script = scriptLines.join('\r\n');
            document.getElementById('final-landscape-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-final-landscape-script-link').href = URL.createObjectURL(blob);
        }

        document.getElementById('final-landscape-script-modal').querySelector('.close').addEventListener('click', () => {
            document.getElementById('final-landscape-script-modal').style.display = 'none';
        });
        document.getElementById('copy-final-landscape-script-btn').addEventListener('click', () => {
            const scriptTextArea = document.getElementById('final-landscape-batch-script');
            scriptTextArea.select();
            navigator.clipboard.writeText(scriptTextArea.value).then(() => {
                alert('Script copied to clipboard!');
                document.getElementById('reload-final-script-page-btn').style.display = 'inline-block';
            });
        });

        document.getElementById('download-final-landscape-script-link').addEventListener('click', () => {
            document.getElementById('reload-final-script-page-btn').style.display = 'inline-block';
        });

        document.getElementById('reload-final-script-page-btn').addEventListener('click', () => {
            location.reload();
        });

        document.getElementById('generate-move-rename-script-btn').addEventListener('click', () => {
            generateMove_rename_script();
            document.getElementById('move-rename-script-modal').style.display = 'block';
        });

        document.getElementById('move-rename-script-modal').querySelector('.close').addEventListener('click', () => {
            document.getElementById('move-rename-script-modal').style.display = 'none';
        });

        document.getElementById('copy-move-rename-script-btn').addEventListener('click', () => {
            const scriptTextArea = document.getElementById('move-rename-batch-script');
            scriptTextArea.select();
            navigator.clipboard.writeText(scriptTextArea.value).then(() => {
                alert('Script copied to clipboard!');
                document.getElementById('reload-move-rename-script-page-btn').style.display = 'inline-block';
            });
        });

        document.getElementById('download-move-rename-script-link').addEventListener('click', () => {
            document.getElementById('reload-move-rename-script-page-btn').style.display = 'inline-block';
        });

        document.getElementById('reload-move-rename-script-page-btn').addEventListener('click', () => {
            location.reload();
        });


        function generateMove_rename_script() {
            const scriptLines = [
                '# PowerShell Script to move and rename files',
                'Write-Host "Processing files..."',
                ''
            ];

            const escapeString = (str) => `'${str.replace(/'/g, "''")}'`;
            const renamedCanvas = Array.from(canvases.values()).find(c => c.name === 'Renamed');

            if (renamedCanvas) {
                const thumbnailsInRenamed = renamedCanvas.thumbnails;
                const groupedByBaseName = new Map();
                
                thumbnailsInRenamed.forEach(thumb => {
                    const newName = thumb.dataset.fileName;
                    if (!newName) return;
                    const baseName = newName.replace(/ \(\d+\)$/, '');
                    if (!groupedByBaseName.has(baseName)) {
                        groupedByBaseName.set(baseName, []);
                    }
                    groupedByBaseName.get(baseName).push(thumb);
                });

                const finalRenames = new Map();
                for (const [baseName, thumbnails] of groupedByBaseName.entries()) {
                    thumbnails.sort((a, b) => {
                        const numA = parseInt((a.dataset.fileName.match(/ \((\d+)\)$/) || [])[1] || 0, 10);
                        const numB = parseInt((b.dataset.fileName.match(/ \((\d+)\)$/) || [])[1] || 0, 10);
                        if (numA !== numB) return numA - numB;
                        const originalA = a.querySelector('.thumbnail-name').dataset.originalFilename;
                        const originalB = b.querySelector('.thumbnail-name').dataset.originalFilename;
                        return originalA.localeCompare(originalB);
                    });

                    let counter = 1;
                    thumbnails.forEach(thumb => {
                        const finalNewName = `${baseName} (${counter})`;
                        finalRenames.set(thumb.dataset.fileName, finalNewName);
                        counter++;
                    });
                }
                
                thumbnailsInRenamed.forEach(thumb => {
                    const originalThumbName = thumb.querySelector('.thumbnail-name').dataset.originalFilename;
                    const newThumbName = finalRenames.get(thumb.dataset.fileName);
                    
                    const originalVideoName = originalThumbName.replace(/\.jpg$/, '.mp4');
                    const videoFile = allVideoFiles.find(f => f.name === originalVideoName);

                    if (videoFile) {
                        const originalPathPrefix = videoFile.customPath ? `${videoFile.customPath}\\` : '';
                        const originalVideoPath = originalPathPrefix + originalVideoName;
                        const originalThumbPath = `Thumbnails\\${originalThumbName}`; // Assuming root thumbnails for simplicity, needs adjustment if thumbs are in subdirs
                        const subDirThumbPath = videoFile.customPath ? `${videoFile.customPath}\\Thumbnails\\${originalThumbName}` : '';
                        
                        const newVideoName = newThumbName.replace(/\.jpg$/, '.mp4');

                        // 1. Move the video file to the root directory first, if it's in a subdirectory
                        if (videoFile.customPath) {
                            scriptLines.push(`if (Test-Path -LiteralPath ${escapeString(originalVideoPath)}) { Move-Item -LiteralPath ${escapeString(originalVideoPath)} -Destination "." }`);
                        }

                        // 2. Rename the video file in the root directory
                        scriptLines.push(`if (Test-Path -LiteralPath ${escapeString(originalVideoName)}) { Rename-Item -LiteralPath ${escapeString(originalVideoName)} -NewName ${escapeString(newVideoName)} }`);
                        
                        // 3. Move and rename the corresponding thumbnail
                        if (subDirThumbPath) {
                            scriptLines.push(`if (Test-Path -LiteralPath ${escapeString(subDirThumbPath)}) { Move-Item -LiteralPath ${escapeString(subDirThumbPath)} -Destination "Thumbnails\\" }`);
                        }
                        scriptLines.push(`if (Test-Path -LiteralPath ${escapeString(originalThumbPath)}) { Rename-Item -LiteralPath ${escapeString(originalThumbPath)} -NewName ${escapeString(newThumbName)} }`);

                        scriptLines.push(''); // Add a blank line for readability
                    }
                });
            }

            scriptLines.push('');
            scriptLines.push('Write-Host "Processing complete."');
            scriptLines.push('Read-Host -Prompt "Press Enter to exit"');

            const script = scriptLines.join('\r\n');
            document.getElementById('move-rename-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-move-rename-script-link').href = URL.createObjectURL(blob);
        }


        function generateBatchScript(videoFiles, dirName) {
            const scriptLines = [
                '@echo off',
                `cd /d "%~dp0"`,
                'echo Creating Thumbnails directory...',
                'if not exist "Thumbnails" mkdir Thumbnails',
                'echo Generating thumbnails...',
                ...videoFiles.map(file => {
                    const fileName = file.name;
                    const thumbnailName = fileName.substring(0, fileName.lastIndexOf('.')) + '.jpg';
                    return `ffmpeg -y -i "${fileName}" -ss 00:00:02.000 -frames:v 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" "Thumbnails\\${thumbnailName}"`;
                }),
                'echo.',
                'echo Thumbnail generation complete.',
                'pause'
            ];
            const script = scriptLines.join('\r\n');
            batchScriptTextArea.value = script;

            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
        }

        function copyScriptToClipboard() {
            batchScriptTextArea.select();
            navigator.clipboard.writeText(batchScriptTextArea.value).then(() => {
                alert('Script copied to clipboard! Paste it into a file named "generate_thumbnails.bat" in your video folder and run it.');
                reloadPageBtn.style.display = 'inline-block';
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        function downloadBatchFile() {
            alert('Once downloaded, move the ".bat" file into your video folder and double-click it to run.');
            reloadPageBtn.style.display = 'inline-block';
        }

        function generateOrphanDeletionScript(orphanedFiles) {
            const scriptLines = [
                '# PowerShell Script to delete orphaned thumbnails',
                'Write-Host "Deleting orphaned thumbnail files (moving to Recycle Bin)..."',
                ...orphanedFiles.map(file => `Remove-Item -LiteralPath "Thumbnails\\${file.name}"`),
                'Write-Host "Deletion complete."',
                'Read-Host -Prompt "Press Enter to exit"'
            ];
            const script = scriptLines.join('\r\n');
            
            // Re-use the main script modal
            scriptModal.querySelector('h2').textContent = 'Delete Orphaned Thumbnails';
            scriptModal.querySelector('p').textContent = 'This PowerShell script will move the orphaned thumbnails to the Recycle Bin.';
            batchScriptTextArea.value = script;
            downloadScriptLink.download = 'delete_orphans.ps1';

            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
            scriptModal.style.display = 'block';
        }


        function promptOrphanedThumbnails(orphanedFiles) {
            return new Promise(resolve => {
                const modal = document.getElementById('orphaned-thumbnails-modal');
                document.getElementById('orphaned-thumbnails-message').textContent = `Found ${orphanedFiles.length} thumbnail(s) without a matching video file. What would you like to do?`;
                
                const fileListDiv = document.getElementById('orphaned-files-list');
                fileListDiv.innerHTML = orphanedFiles.map(f => `<div>${f.name}</div>`).join('');

                const deleteBtn = document.getElementById('delete-orphans-script-btn');
                const hideBtn = document.getElementById('hide-orphans-btn');
                const hideForeverBtn = document.getElementById('hide-forever-orphans-btn');
                const doNothingBtn = document.getElementById('do-nothing-orphans-btn');
                const closeBtn = modal.querySelector('.close');

                const cleanup = () => {
                    // Replace buttons to remove event listeners
                    deleteBtn.replaceWith(deleteBtn.cloneNode(true));
                    hideBtn.replaceWith(hideBtn.cloneNode(true));
                    hideForeverBtn.replaceWith(hideForeverBtn.cloneNode(true));
                    doNothingBtn.replaceWith(doNothingBtn.cloneNode(true));
                    closeBtn.replaceWith(closeBtn.cloneNode(true));
                    modal.style.display = 'none';
                };

                deleteBtn.addEventListener('click', () => { cleanup(); resolve('delete'); }, { once: true });
                hideBtn.addEventListener('click', () => { cleanup(); resolve('hide'); }, { once: true });
                hideForeverBtn.addEventListener('click', () => { cleanup(); resolve('hideForever'); }, { once: true });
                
                const doNothingHandler = () => {
                    cleanup();
                    resolve('nothing');
                };
                doNothingBtn.addEventListener('click', doNothingHandler, { once: true });
                closeBtn.addEventListener('click', doNothingHandler, { once: true });

                modal.style.display = 'block';
            });
        }

        reloadPageBtn.addEventListener('click', () => {
            location.reload();
        });
        
        function initializeFilenameBuilder() {
            filenamePartsContainer.innerHTML = '';
            // Start with a category and one element
            filenameParts = [{ type: 'category', value: '' }, { type: 'element', value: '' }];
            renderFilenameParts();
            updateFilenamePreview();
            populatePreviousElements();
            populatePreviousCategories();
        }

        function renderFilenameParts() {
            filenamePartsContainer.innerHTML = '';
            filenameParts.forEach((part, index) => {
                const row = document.createElement('div');
                row.className = 'filename-part-row';

                const input = document.createElement('input');
                input.type = 'text';
                input.value = part.value;

                if (part.type === 'category') {
                    input.placeholder = 'Category';
                    input.setAttribute('list', 'previous-categories-list');
                } else {
                    input.placeholder = `Element ${index}`;
                    input.setAttribute('list', 'previous-elements-list');
                }

                input.addEventListener('input', () => {
                    part.value = input.value;
                    updateFilenamePreview();
                });

                row.appendChild(input);

                if (index > 0) { // Can't remove the 'Category'
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '-';
                    removeBtn.onclick = () => removeFilenamePart(index);
                    row.appendChild(removeBtn);
                }
                filenamePartsContainer.appendChild(row);
            });
        }

        function updateFilenamePreview() {
            const username = projectUsernameInput.value || 'username';
            const category = filenameParts[0]?.value.trim() || 'Category';
            
            const elements = filenameParts.slice(1)
                .map(p => p.value.trim())
                .filter(p => p);

            // Build a representative filename string for the preview
            const elementsString = elements.map(e => `(${e})`).join(' ');
            filenamePreview.textContent = `[${username}]_${category} ${elementsString} (1).mp4`;

            // Also show the final button text and structure
            if (elements.length > 0) {
                const buttonName = elements[elements.length - 1];
                let structure = category;
                if (elements.length > 1) {
                    structure += ` -> ${elements.slice(0, -1).join(' -> ')}`;
                }
                filenamePreview.textContent += `\nButton: "${buttonName}" under "${structure}"`;
            }
        }

        function addFilenamePart(value = '') {
            filenameParts.push({ type: 'element', value });
            renderFilenameParts();
            updateFilenamePreview();
        }

        function removeFilenamePart(index) {
            if (filenameParts.length > 2) { // Always keep at least one category and one element
                filenameParts.splice(index, 1);
                renderFilenameParts();
                updateFilenamePreview();
            }
        }

        function getPreviousElements() {
            const projectData = loadProjectData(directoryName);
            return projectData.previousFilenameElements || [];
        }

        function populatePreviousElements() {
            const values = getPreviousElements();
            const datalist = document.getElementById('previous-elements-list');
            datalist.innerHTML = '';
            values.forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                datalist.appendChild(option);
            });
        }

        function getPreviousCategories() {
            const projectData = loadProjectData(directoryName);
            return projectData.previousFilenameCategories || [];
        }

        function populatePreviousCategories() {
            const categories = getPreviousCategories();
            const datalist = document.getElementById('previous-categories-list');
            datalist.innerHTML = '';
            categories.forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                datalist.appendChild(option);
            });
        }

        document.getElementById('add-element-btn').addEventListener('click', () => addFilenamePart());

        function openButtonEditor(buttonId) {
            const projectData = loadProjectData(directoryName);
            const { button, path } = findButtonPathById(projectData.customButtonTree, buttonId);

            if (!button || !path) {
                console.error("Button not found for editing:", buttonId);
                return;
            }

            const elements = path.slice(1); 

            filenameParts = [
                { type: 'category', value: path[0] || '' },
                ...elements.map(el => ({ type: 'element', value: el }))
            ];
            
            // Store the original state for the copy-on-no-change logic
            originalPartsForCopyCheck = JSON.stringify(filenameParts);

            renderFilenameParts();
            updateFilenamePreview();

            // When copying, we are creating a NEW button, so the ID should be empty.
            document.getElementById('editing-button-id').value = '';
            createFilenameButtonBtn.textContent = 'Add Button';
            document.getElementById('clone-filename-button-btn').style.display = 'none';
            filenameBuilderModal.style.display = 'block';
        }

        function findButtonPathById(tree, id, currentPath = []) {
            for (const node of tree) {
                 if (node.type === 'button' && String(node.id) === String(id)) {
                    return { button: node, path: [...currentPath, node.name] };
                }
                if (node.type === 'category' && node.children) {
                    const result = findButtonPathById(node.children, id, [...currentPath, node.name]);
                    if (result.button) return result;
                }
            }
            return {};
        }

        function removeButtonFromTreeById(tree, id) {
             if (!Array.isArray(tree)) return [];
            
            let filteredNodes = tree.filter(node => 
                !(node.type === 'button' && String(node.id) === String(id))
            );

            return filteredNodes.map(node => {
                if (node.type === 'category' && node.children) {
                    node.children = removeButtonFromTreeById(node.children, id);
                }
                return node;
            }).filter(node => !(node.type === 'category' && (!node.children || node.children.length === 0)));
        }

        function createOrUpdateButton() {
            const editingButtonId = document.getElementById('editing-button-id').value;
            const isUpdate = !!editingButtonId;

            const category = filenameParts[0]?.value.trim();
            if (!category) {
                alert('A "Category" is required.');
                return;
            }

            let elements = filenameParts.slice(1).map(p => p.value.trim()).filter(p => p);
            if (elements.length === 0) {
                alert('At least one "Element" is required.');
                return;
            }

            // Logic to append "(Copy)" if no changes were made
            const currentPartsString = JSON.stringify(filenameParts);
            if (!isUpdate && currentPartsString === originalPartsForCopyCheck) {
                const lastElementIndex = filenameParts.length - 1;
                if (lastElementIndex > 0) { // Ensure there is an element to modify
                    filenameParts[lastElementIndex].value += ' (Copy)';
                    // Re-extract elements after modification
                    elements = filenameParts.slice(1).map(p => p.value.trim()).filter(p => p);
                }
            }
            
            const projectData = loadProjectData(directoryName);

            // Save new elements to suggestions
            elements.forEach(el => {
                if (el && !projectData.previousFilenameElements?.includes(el)) {
                    (projectData.previousFilenameElements = projectData.previousFilenameElements || []).push(el);
                }
            });
            if (category && !projectData.previousFilenameCategories?.includes(category)) {
                 (projectData.previousFilenameCategories = projectData.previousFilenameCategories || []).push(category);
            }

            let customButtonTree = projectData.customButtonTree;

            if (isUpdate) {
                customButtonTree = removeButtonFromTreeById(customButtonTree, editingButtonId);
            }
            
            let path = [category, ...elements];
            let buttonData = {
                fullButtonText: elements.map(p => `(${p})`).join(' '),
                id: isUpdate ? editingButtonId : Date.now() + Math.random()
            };

            if (!insertButtonIntoTree(customButtonTree, path, buttonData)) {
                alert('A button with this exact name and category structure already exists.');
                if (isUpdate) { 
                     loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                }
                return;
            }

            projectData.customButtonTree = customButtonTree;
            saveProjectData(directoryName, projectData);
            loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
            filenameBuilderModal.style.display = 'none';
            populatePreviousElements();
            populatePreviousCategories();
            originalPartsForCopyCheck = null; // Reset tracker
        }
        
        createFilenameButtonBtn.addEventListener('click', () => createOrUpdateButton());


        async function loadCustomButtons(customButtonTree, collapseState, buttonVisibility) {
            if (!directoryName) {
                return;
            }
            const scrollContainer = document.getElementById('sidebar-scroll-container');
            scrollContainer.innerHTML = '';
            const numElements = parseInt(document.getElementById('num-elements-input').value, 10);

            const createCollapseClickHandler = (key) => (event) => {
                event.stopPropagation();
                const projectData = loadProjectData(directoryName);
                projectData.collapseState[key] = !projectData.collapseState[key];
                saveProjectData(directoryName, projectData);
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
            };

            function renderTree(nodes, parentContainer, level, parentPath) {
                if (!Array.isArray(nodes)) return;
                
                nodes.sort((a, b) => {
                    if (a.name === '+1') return -1;
                    if (b.name === '+1') return 1;
                    return a.name.localeCompare(b.name);
                });

                nodes.forEach(node => {
                    const currentPath = [...parentPath, node.name];
                    const nodeKey = `node_${currentPath.join('_')}`;

                    if (node.type === 'category' && level < numElements) {
                        const isCollapsed = collapseState[nodeKey] || false;
                        const header = document.createElement(`h${4 + level}`);
                        header.textContent = currentPath.join('-');
                        header.style.marginLeft = `${level * 8}px`;
                        header.style.cursor = 'pointer';
                        header.onclick = createCollapseClickHandler(nodeKey);
                        parentContainer.appendChild(header);

                        if (!isCollapsed && Array.isArray(node.children)) {
                            renderTree(node.children, parentContainer, level + 1, currentPath);
                        }
                    } else {
                        function createButtonsFromSubtree(startingNode, basePath, textParts) {
                            if (startingNode.type === 'button') {
                                if (buttonVisibility[startingNode.id] === false) return;
                                
                                const combinedName = [...textParts, startingNode.name].join(' ');
                                const finalButtonName = startingNode.specialType === 'plusOne' ? '+1' : combinedName;
                                
                                parentContainer.appendChild(createSidebarButton({ ...startingNode, name: finalButtonName }, basePath));

                            } else if (startingNode.type === 'category' && Array.isArray(startingNode.children)) {
                                const newTextParts = [...textParts, startingNode.name];
                                const sortedChildren = [...startingNode.children].sort((a, b) => {
                                    if (a.name === '+1') return -1;
                                    if (b.name === '+1') return 1;
                                    return a.name.localeCompare(b.name);
                                });
                                sortedChildren.forEach(child => {
                                    createButtonsFromSubtree(child, basePath, newTextParts);
                                });
                            }
                        }
                        // By passing an empty array `[]` as the initial textParts, we prevent the
                        // duplication bug where the starting node's name was added twice. The
                        // recursive function is responsible for building the entire name string.
                        createButtonsFromSubtree(node, currentPath.slice(0, numElements), []);
                    }
                });
            }

            renderTree(customButtonTree, scrollContainer, 0, []);
        }

    function populateVisibleButtonsModal() {
        visibleButtonsListContainer.innerHTML = '';
        const projectData = loadProjectData(directoryName);
        let customButtonTree = projectData.customButtonTree;
        const buttonVisibility = projectData.buttonVisibility;
        const numElements = parseInt(document.getElementById('num-elements-input').value, 10);

        // We'll use a modified render function to build the checklist
        function renderVisibilityChecklist(nodes, parentContainer, level, parentPath = []) {
            if (!Array.isArray(nodes)) return;

            // Use the same sorting as the main render function
            nodes.sort((a, b) => {
                if (a.name === '+1') return -1;
                if (b.name === '+1') return 1;
                if (a.type === 'category' && b.type !== 'category') return -1;
                if (a.type !== 'category' && b.type === 'category') return 1;
                return a.name.localeCompare(b.name);
            });

            nodes.forEach(node => {
                const currentPath = [...parentPath, node.name];
                if (node.type === 'category' && level <= numElements) {
                    const header = document.createElement(`h${4 + level}`);
                    header.textContent = currentPath.join('-');
                    header.style.marginLeft = `${level * 8}px`;
                    header.style.color = 'black';
                    parentContainer.appendChild(header);
                    
                    const childrenContainer = document.createElement('div');
                    renderVisibilityChecklist(node.children, childrenContainer, level + 1);
                    parentContainer.appendChild(childrenContainer);

                } else {
                     function createCheckboxesFromSubtree(startingNode, textParts) {
                        if (startingNode.type === 'button') {
                            const allTextParts = [...textParts, startingNode.name];
                            const buttonName = startingNode.specialType === 'plusOne' 
                                ? '+1'
                                : allTextParts.filter(p => p !== '+1').join(' ');
                            
                            const div = document.createElement('div');
                            div.style.marginLeft = `${(numElements + 1) * 8}px`;
                            div.style.display = 'flex';
                            div.style.alignItems = 'center';

                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.id = `vis-check-${startingNode.id}`;
                            checkbox.checked = buttonVisibility[startingNode.id] !== false; // Default to visible
                            
                            checkbox.onchange = () => {
                                const buttonId = String(startingNode.id);
                                projectData.buttonVisibility[buttonId] = checkbox.checked;

                                if (!checkbox.checked) {
                                    // If the button is being hidden, deselect it from the removal list
                                    if (buttonsForRemoval.has(buttonId)) {
                                        buttonsForRemoval.delete(buttonId);
                                    }

                                    // Also, deselect it from the "rename" state
                                    const renameBtn = document.getElementById('rename-btn');
                                    const lastClickedData = JSON.parse(renameBtn.dataset.lastClicked || 'null');
                                    if (lastClickedData && String(lastClickedData.id) === buttonId) {
                                        delete renameBtn.dataset.lastClicked;
                                        updatePreviewPanel(null); // Clear the preview panel as well
                                    }

                                    updateSidebarActionButtonsState();
                                    updateBottomBarInfo();
                                }

                                saveProjectData(directoryName, projectData);
                                // The loadCustomButtons function will redraw the sidebar, effectively
                                // removing the .selected-for-removal class from the now-hidden button.
                                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                            };

                            const label = document.createElement('label');
                            label.htmlFor = checkbox.id;
                            label.textContent = buttonName;
                            label.style.color = 'black';
                            label.style.marginLeft = '4px';

                            div.appendChild(checkbox);
                            div.appendChild(label);
                            parentContainer.appendChild(div);

                        } else if (startingNode.type === 'category') {
                            const newTextParts = [...textParts, startingNode.name];
                            if(Array.isArray(startingNode.children)) {
                                startingNode.children.forEach(child => createCheckboxesFromSubtree(child, newTextParts));
                            }
                        }
                    }
                    createCheckboxesFromSubtree(node, []);
                }
            });
        }

        renderVisibilityChecklist(customButtonTree, visibleButtonsListContainer, 0, []);
    }

    visibleButtonsBtn.addEventListener('click', () => {
        populateVisibleButtonsModal();
        visibleButtonsModal.style.display = 'block';
    });

    visibleButtonsModal.querySelector('.close').addEventListener('click', () => {
        visibleButtonsModal.style.display = 'none';
    });

        function updateBottomBarInfo() {
            const infoDiv = document.getElementById('bottom-bar-info');

            // Priority 1: Display info about sidebar buttons selected for removal.
            if (buttonsForRemoval.size === 1) {
                const buttonId = buttonsForRemoval.values().next().value;
                const projectData = loadProjectData(directoryName);
                let customButtonTree = projectData.customButtonTree;

                function findButtonPath(nodes, id, currentPath = []) {
                    for (const node of nodes) {
                        if (node.type === 'button' && String(node.id) === String(id)) {
                            return { button: node, path: currentPath };
                        }
                        if (node.type === 'category' && node.children) {
                            const result = findButtonPath(node.children, id, [...currentPath, node.name]);
                            if (result) return result;
                        }
                    }
                    return null;
                }
                
                const result = findButtonPath(customButtonTree, buttonId);
                if (result && result.path.length > 0) {
                    const username = projectUsernameInput.value.trim() || 'username';
                    const category = result.path[0];
                    const fullButtonText = result.button.fullButtonText;
                    const constructedName = `[${username}]_${category} ${fullButtonText}`;
                    infoDiv.textContent = constructedName.replace(/\s*\(\d+\)$/, '').trim();
                } else {
                    infoDiv.textContent = '1 sidebar button selected';
                }
                 return; // Exit after showing button info

            } else if (buttonsForRemoval.size > 1) {
                infoDiv.textContent = `${buttonsForRemoval.size} sidebar buttons selected`;
                return; // Exit after showing button info
            }

            // Priority 2: Display info about selected thumbnails.
            if (selectedThumbnails.size === 1) {
                const singleThumbnail = selectedThumbnails.values().next().value;
                infoDiv.textContent = singleThumbnail.dataset.fileName;
            } else if (selectedThumbnails.size > 1) {
                infoDiv.textContent = `${selectedThumbnails.size} items selected`;
            } else {
                infoDiv.textContent = '';
            }
        }

        function createSidebarButton(buttonData, path) {
            const { id, name, fullButtonText, specialType } = buttonData;
            
            const container = document.createElement('div');
            container.className = 'sidebar-button-container';
            container.style.position = 'relative';

            const button = document.createElement('button');
            button.textContent = name.replace(/[()]/g, '');
            button.dataset.id = id;
            const numElements = parseInt(document.getElementById('num-elements-input').value, 10);
            button.style.paddingLeft = `${(numElements) * 8}px`;

            if (buttonsForRemoval.has(String(id))) {
                button.classList.add('selected-for-removal');
            }

            button.onclick = () => {
                const buttonId = button.dataset.id;
                const isCurrentlySelected = button.classList.contains('selected-for-removal');
                const renameBtn = document.getElementById('rename-btn');
                const buttonInfo = { id, name, fullButtonText, specialType, path };

                if (isCurrentlySelected) {
                    buttonsForRemoval.delete(buttonId);
                    button.classList.remove('selected-for-removal');
                    delete renameBtn.dataset.lastClicked;
                    updatePreviewPanel(null); // Clear the preview
                } else {
                    // When switching to a new button, deselect any thumbnails that were manually selected.
                    if (selectedThumbnails.size > 0) {
                        selectedThumbnails.forEach(thumb => thumb.classList.remove('selected'));
                        selectedThumbnails.clear();
                    }
                    
                    document.querySelectorAll('#sidebar-scroll-container button.selected-for-removal').forEach(b => {
                        b.classList.remove('selected-for-removal');
                        buttonsForRemoval.delete(b.dataset.id);
                    });
                    buttonsForRemoval.add(buttonId);
                    button.classList.add('selected-for-removal');
                    
                    renameBtn.dataset.lastClicked = JSON.stringify(buttonInfo);
                    updatePreviewPanel(buttonInfo);
                }

                updateSidebarActionButtonsState();
                updateBottomBarInfo();
                highlightMatchingThumbnails(path, fullButtonText, !isCurrentlySelected, specialType === 'plusOne');
            };


            const fontSize = document.getElementById('font-size-slider').value;
             button.style.cssText += `
                width: 100%; margin: 0; padding-top: 0; padding-bottom: 0; height: 36px;
                background-color: #1877f2; color: #ffffff; border: 1px solid #444444;
                border-top: none; border-radius: 0; font-size: ${fontSize}px; cursor: pointer;
                box-sizing: border-box; text-align: left; display: block;
            `;
            button.style.textAlign = 'left';
            
            adjustButtonFontSize(button);
            container.appendChild(button);
            return container;
        }

        function highlightMatchingThumbnails(path, fullButtonText, shouldSelect, isCategoryOnly) {
            const username = projectUsernameInput.value.trim();
            if (!username) return;

            const category = path[0];
            const prefix = `[${username}]_${category}`;

            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas) {
                currentCanvas.thumbnails.forEach(thumb => {
                    const baseFilename = thumb.dataset.fileName.substring(0, thumb.dataset.fileName.lastIndexOf('.'));
                    const filenameWithoutNumber = baseFilename.replace(/\s*\(\d+\)$/, '').trim();
                    
                    let matches = false;
                    if (isCategoryOnly) {
                        // For +1, we want an exact match with the prefix, and nothing after it.
                        matches = filenameWithoutNumber === prefix;
                    } else {
                        // For regular buttons, it must start with the prefix and contain the elements.
                        const expectedFilenamePart = `${prefix} ${fullButtonText}`;
                        matches = filenameWithoutNumber.startsWith(expectedFilenamePart);
                    }

                    if (matches) {
                        if (shouldSelect) {
                            if (!selectedThumbnails.has(thumb)) {
                                thumb.classList.add('selected');
                                selectedThumbnails.add(thumb);
                            }
                        } else {
                            if (selectedThumbnails.has(thumb)) {
                                thumb.classList.remove('selected');
                                selectedThumbnails.delete(thumb);
                            }
                        }
                    }
                });
            }
            updatePlayButtonState();
            updateBottomBarInfo();
        }

        function adjustButtonFontSize(button) {
            const fontSize = document.getElementById('font-size-slider').value;
            button.style.fontSize = `${fontSize}px`;
        }

        newFilenameBtn.addEventListener('click', () => {
            filenameBuilderModal.style.display = 'block';
            initializeFilenameBuilder();
            // Reset to "create" mode
            document.getElementById('editing-button-id').value = '';
            createFilenameButtonBtn.textContent = 'Add Button';
            document.getElementById('clone-filename-button-btn').style.display = 'none';
        });

        removeBtn.addEventListener('click', () => {
            if (buttonsForRemoval.size === 0) {
                alert('Please select one or more buttons to remove.');
                return;
            }

            if (confirm(`Are you sure you want to remove ${buttonsForRemoval.size} button(s)?`)) {
                const projectData = loadProjectData(directoryName);
                let buttonTree = projectData.customButtonTree;
                
                function removeButtonsFromTree(nodes) {
                    if (!Array.isArray(nodes)) return [];
                    
                    // Filter out leaf buttons that should be removed
                    let filteredNodes = nodes.filter(node => {
                        return !(node.type === 'button' && buttonsForRemoval.has(String(node.id)));
                    });

                    // Recurse into remaining category nodes
                    return filteredNodes.map(node => {
                        if (node.type === 'category' && node.children) {
                            node.children = removeButtonsFromTree(node.children);
                        }
                        return node;
                    // After removing children, a category might become empty. Remove it.
                    }).filter(node => !(node.type === 'category' && (!node.children || node.children.length === 0)));
                }
                
                const newButtonTree = removeButtonsFromTree(buttonTree);
                projectData.customButtonTree = newButtonTree;
                saveProjectData(directoryName, projectData);

                buttonsForRemoval.clear();
                loadCustomButtons(projectData.customButtonTree, projectData.collapseState, projectData.buttonVisibility);
                updateSidebarActionButtonsState();
                updateBottomBarInfo();
                updatePreviewPanel(); // Clear preview panel
            }
        });

        filenameBuilderModal.querySelector('.close').addEventListener('click', () => {
            filenameBuilderModal.style.display = 'none';
        });

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            let mouseDownEvent = null;

            element.addEventListener('dragstart', (e) => e.preventDefault());
            element.onmousedown = dragMouseDown;

            element.addEventListener('dblclick', () => {
                playlist = [element];
                const contentArea = document.getElementById('content-area');
                const rect = contentArea.getBoundingClientRect();
                videoOverlay.style.top = `${rect.top}px`;
                videoOverlay.style.left = `${rect.left}px`;
                videoOverlay.style.width = `${rect.width}px`;
                videoOverlay.style.height = `${rect.height}px`;
                videoOverlay.style.display = 'flex';
                loadVideo(0);
            });

            function dragMouseDown(e) {
                const isPreview = !!element.closest('#preview-container');
                
                e = e || window.event;
                e.preventDefault();
                isDragging = false;
                mouseDownEvent = e;

                pos3 = e.clientX;
                pos4 = e.clientY;

                if (!isLayoutFrozen && !isPreview) {
                    freezeLayout();
                }

                if (selectedThumbnails.has(element)) {
                    selectedThumbnails.forEach(thumb => {
                        thumb.style.zIndex = zIndexCounter++;
                    });
                } else {
                    element.style.zIndex = zIndexCounter++;
                }
                
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                isDragging = true;
                e = e || window.event;
                e.preventDefault();

                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                const isPreview = !!element.closest('#preview-container');
                const container = isPreview ? previewContainer : thumbnailContainer;
                const selectionSet = isPreview ? selectedPreviewThumbnails : selectedThumbnails;

                if (selectionSet.has(element)) {
                    selectionSet.forEach(thumb => {
                        let newTop = thumb.offsetTop - pos2;
                        let newLeft = thumb.offsetLeft - pos1;

                        if (newLeft < 0) newLeft = 0;
                        if (newTop < 0) newTop = 0;
                        
                        thumb.style.top = newTop + "px";
                        thumb.style.left = newLeft + "px";
                    });
                } else {
                    let newTop = element.offsetTop - pos2;
                    let newLeft = element.offsetLeft - pos1;

                    if (newLeft < 0) newLeft = 0;
                    if (newTop < 0) newTop = 0;
                    
                    element.style.top = newTop + "px";
                    element.style.left = newLeft + "px";
                }
            }

            function closeDragElement() {
                const isPreview = !!element.closest('#preview-container');
                 if (!isDragging) { // This is a click, not a drag
                    const wrapper = element;
                    const clickEvent = mouseDownEvent; // Use the stored mousedown event
                    const selectionSet = isPreview ? selectedPreviewThumbnails : selectedThumbnails;
                    
                    if (isPreview) {
                        if (selectionSet.has(wrapper)) {
                            wrapper.classList.remove('selected');
                            selectionSet.delete(wrapper);
                        } else {
                            wrapper.classList.add('selected');
                            selectionSet.add(wrapper);
                        }
                    } else { // Main container logic
                        if (isMultiSelectMode || (clickEvent && (clickEvent.ctrlKey || clickEvent.metaKey))) {
                            if (selectionSet.has(wrapper)) {
                                wrapper.classList.remove('selected');
                                selectionSet.delete(wrapper);
                            } else {
                                wrapper.classList.add('selected');
                                selectionSet.add(wrapper);
                            }
                        } else {
                            selectionSet.forEach(t => t.classList.remove('selected'));
                            selectionSet.clear();
                            wrapper.classList.add('selected');
                            selectionSet.add(wrapper);
                        }
                        updatePlayButtonState();
                        updateBottomBarInfo();
                        updatePreviewPanel(); // Update preview on selection change
                    }
                }

                document.onmouseup = null;
                document.onmousemove = null;

                if (!isPreview && isDragging) { // Only save/update spacer if something was dragged in main container
                    saveCanvasState();
                    updateContentSpacer();
                }
            }
        }

        function freezeLayout() {
            const wrappers = thumbnailContainer.querySelectorAll('.thumbnail-wrapper');
            if (wrappers.length === 0) return;

            const positions = [];
            wrappers.forEach(wrapper => {
                positions.push({
                    left: wrapper.offsetLeft,
                    top: wrapper.offsetTop
                });
            });

            wrappers.forEach((wrapper, index) => {
                wrapper.style.position = 'absolute';
                wrapper.style.left = positions[index].left + 'px';
                wrapper.style.top = positions[index].top + 'px';
            });
            
            isLayoutFrozen = true;
            updateContentSpacer();
        }

        function sortThumbnails(sortBy) {
            const canvas = canvases.get(activeCanvasId);
            if (!canvas) return;

            isLayoutFrozen = false; // Allow grid to be recalculated

            if (sortBy === 'name') {
                canvas.thumbnails.sort((a, b) => a.dataset.fileName.localeCompare(b.dataset.fileName));
            } else if (sortBy === 'random') {
                canvas.thumbnails.sort(() => Math.random() - 0.5);
            }
            renderCanvas(activeCanvasId);
            // After rendering a sorted grid, we immediately freeze it to capture positions
            freezeLayout(); 
            saveCanvasState();
        }

        function saveLayout() {
            const layoutName = layoutNameInput.value.trim();
            if (!layoutName) {
                alert('Please enter a name for the layout.');
                layoutNameInput.focus();
                return;
            }
            if (!isLayoutFrozen) {
                alert('Please move at least one thumbnail before saving the layout.');
                return;
            }

            const thumbnails = document.querySelectorAll('.thumbnail');
            const layoutData = {
                positions: {},
                size: sizeSelector.value
            };
            thumbnails.forEach(thumb => {
                layoutData.positions[thumb.dataset.fileName] = {
                    left: thumb.style.left,
                    top: thumb.style.top
                };
            });
            
            const projectData = loadProjectData(directoryName);
            projectData.layouts[layoutName] = layoutData;
            saveProjectData(directoryName, projectData);
            
            layoutNameInput.value = '';
            populateLayoutsDropdown();
            alert(`Layout "${layoutName}" saved!`);
        }

        layoutNameInput.addEventListener('input', () => {
            if (layoutNameInput.value.trim() !== '') {
                saveLayoutBtn.textContent = 'Save Layout';
            }
        });

        function loadLayout() {
            const selectedValue = layoutSelect.value;
            if (!selectedValue) return;

            if (selectedValue.startsWith('scan_')) {
                const layoutName = selectedValue.replace('scan_', '');
                const layoutData = scanLayouts[layoutName];
                if (layoutData) {
                    applyScanLayout(layoutData);
                }
                return;
            }

            const projectData = loadProjectData(directoryName);
            const layoutData = projectData.layouts[selectedValue];
            
            if (!layoutData) return;

            if (!isLayoutFrozen) {
                freezeLayout();
            }
            
            sizeSelector.value = layoutData.size;
            
            const wrappers = thumbnailContainer.querySelectorAll('.thumbnail-wrapper');
            wrappers.forEach(wrapper => {
                const pos = layoutData.positions[wrapper.dataset.fileName];
                if (pos) {
                    wrapper.style.left = pos.left;
                    wrapper.style.top = pos.top;
                }
            });
            layoutThumbnailsInGrid(); // This will handle applying the size and updating the spacer
            saveCanvasState();
        }

        function deleteLayout() {
            const layoutName = layoutSelect.value;
            if (!layoutName) {
                alert('Please select a layout to delete.');
                return;
            }
            if (confirm(`Are you sure you want to delete the "${layoutName}" layout?`)) {
                const projectData = loadProjectData(directoryName);
                delete projectData.layouts[layoutName];
                saveProjectData(directoryName, projectData);
                populateLayoutsDropdown();
            }
        }

        function applyScanLayout(layoutData) {
            if (!isLayoutFrozen) {
                freezeLayout();
            }

            const projectData = loadProjectData(directoryName);
            const verticalPadding = parseInt(projectData.verticalPadding, 10) || 0;
            const horizontalPadding = parseInt(projectData.horizontalPadding, 10) || 0;

            const allWrappers = Array.from(thumbnailContainer.querySelectorAll('.thumbnail-wrapper'));
            const wrapperMap = new Map(allWrappers.map(w => [w.dataset.fileName, w]));
            const placedWrappers = new Set();
            let currentY = verticalPadding;

            layoutData.sort((a, b) => a.Header.localeCompare(b.Header));

            layoutData.forEach(group => {
                if (group.IsGroup && Array.isArray(group.AllChildren)) {
                    let currentX = horizontalPadding;
                    let maxRowHeight = 0;

                    group.AllChildren.forEach(child => {
                        const pathParts = child.Item.ItemInfo.Path.split('\\');
                        const videoFilename = pathParts[pathParts.length - 1];
                        const thumbFilename = videoFilename.substring(0, videoFilename.lastIndexOf('.')) + '.jpg';
                        
                        const wrapper = wrapperMap.get(thumbFilename);
                        if (wrapper) {
                            if (currentX > horizontalPadding && currentX + wrapper.offsetWidth > thumbnailContainer.clientWidth) {
                                currentX = horizontalPadding;
                                currentY += maxRowHeight + verticalPadding;
                                maxRowHeight = 0;
                            }
                            wrapper.style.left = currentX + 'px';
                            wrapper.style.top = currentY + 'px';
                            currentX += wrapper.offsetWidth + horizontalPadding;
                            if (wrapper.offsetHeight > maxRowHeight) {
                                maxRowHeight = wrapper.offsetHeight;
                            }
                            placedWrappers.add(wrapper);
                        }
                    });

                    if (group.AllChildren.length > 0) {
                        currentY += maxRowHeight + verticalPadding; // Move to the next row for the next group
                    }
                }
            });

            // Handle ungrouped thumbnails
            let currentX = horizontalPadding;
            let maxRowHeight = 0;
            allWrappers.forEach(wrapper => {
                if (!placedWrappers.has(wrapper)) {
                    if (currentX > horizontalPadding && currentX + wrapper.offsetWidth > thumbnailContainer.clientWidth) {
                        currentX = horizontalPadding;
                        currentY += maxRowHeight + verticalPadding;
                        maxRowHeight = 0;
                    }
                    wrapper.style.left = currentX + 'px';
                    wrapper.style.top = currentY + 'px';
                    currentX += wrapper.offsetWidth + horizontalPadding;
                    if (wrapper.offsetHeight > maxRowHeight) {
                        maxRowHeight = wrapper.offsetHeight;
                    }
                }
            });

            updateContentSpacer();
            saveCanvasState();
        }

        function populateLayoutsDropdown() {
            const projectData = loadProjectData(directoryName);
            const savedLayoutNames = Object.keys(projectData.layouts);
            const scanLayoutNames = Object.keys(scanLayouts);

            layoutSelect.innerHTML = '<option value="" disabled hidden>Select Layout</option>';

            if (scanLayoutNames.length > 0) {
                const scanGroup = document.createElement('optgroup');
                scanGroup.label = 'Scan Layouts';
                scanLayoutNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = `scan_${name}`;
                    option.textContent = name;
                    scanGroup.appendChild(option);
                });
                layoutSelect.appendChild(scanGroup);
            }

            if (savedLayoutNames.length > 0) {
                const savedGroup = document.createElement('optgroup');
                savedGroup.label = 'Saved Layouts';
                savedLayoutNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    savedGroup.appendChild(option);
                });
                layoutSelect.appendChild(savedGroup);
            }
        }

        function startSelection(e) {
            if (e.target !== thumbnailContainer) return;
            e.preventDefault();

            const containerRect = thumbnailContainer.getBoundingClientRect();
            let startX = e.clientX - containerRect.left + thumbnailContainer.scrollLeft;
            let startY = e.clientY - containerRect.top + thumbnailContainer.scrollTop;

            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';

            document.addEventListener('mousemove', handleSelection);
            document.addEventListener('mouseup', endSelection);

            function handleSelection(e) {
                let currentX = e.clientX - containerRect.left + thumbnailContainer.scrollLeft;
                let currentY = e.clientY - containerRect.top + thumbnailContainer.scrollTop;

                let newLeft = Math.min(startX, currentX);
                let newTop = Math.min(startY, currentY);
                let newWidth = Math.abs(startX - currentX);
                let newHeight = Math.abs(startY - currentY);

                selectionBox.style.left = newLeft + 'px';
                selectionBox.style.top = newTop + 'px';
                selectionBox.style.width = newWidth + 'px';
                selectionBox.style.height = newHeight + 'px';
            }

            function endSelection(e) {
                document.removeEventListener('mousemove', handleSelection);
                document.removeEventListener('mouseup', endSelection);
                
                selectThumbnailsInBox();
                selectionBox.style.display = 'none';
            }
        }

        function selectThumbnailsInBox() {
            const boxRect = selectionBox.getBoundingClientRect();
            const wrappers = document.querySelectorAll('.thumbnail-wrapper');

            if (!isMultiSelectMode) {
                selectedThumbnails.forEach(t => t.classList.remove('selected'));
                selectedThumbnails.clear();
            }
            
            wrappers.forEach(wrapper => {
                const wrapperRect = wrapper.getBoundingClientRect();
                
                if (
                    boxRect.left < wrapperRect.right &&
                    boxRect.right > wrapperRect.left &&
                    boxRect.top < wrapperRect.bottom &&
                    boxRect.bottom > wrapperRect.top
                ) {
                    if (!selectedThumbnails.has(wrapper)) {
                       wrapper.classList.add('selected');
                       selectedThumbnails.add(wrapper);
                    }
                }
            });
            updatePlayButtonState();
            updateBottomBarInfo();
            updatePreviewPanel();
            saveCanvasState();
        }

        const resizer = document.getElementById('sidebar-resizer');
        const sidebar = document.getElementById('sidebar');

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();

            const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                // Adjust font size for all buttons after resizing
                const buttons = document.querySelectorAll('#sidebar-scroll-container button');
                buttons.forEach(button => adjustButtonFontSize(button));
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });

        function handleMouseMove(e) {
            const newWidth = e.clientX;
            if (newWidth > 100 && newWidth < 500) { // Min and max width
                sidebar.style.width = newWidth + 'px';
            }
        }

        previewBtn.addEventListener('click', () => {
            const isHidden = rightSidebar.style.display === 'none';
            rightSidebar.style.display = isHidden ? 'flex' : 'none';

            if (directoryName) {
                const projectData = loadProjectData(directoryName);
                projectData.previewSidebarVisible = isHidden;
                saveProjectData(directoryName, projectData);
            }
        });

        document.getElementById('play-all-preview-btn').addEventListener('click', () => {
            const previewThumbnails = Array.from(previewContainer.querySelectorAll('.thumbnail-wrapper'));
            if (previewThumbnails.length > 0) {
                playlist = previewThumbnails;
                videoOverlay.style.display = 'flex';
                loadVideo(0);
            }
        });

        const rightResizer = document.getElementById('right-sidebar-resizer');
        rightResizer.addEventListener('mousedown', (e) => {
            e.preventDefault();

            const handleRightMouseUp = () => {
                document.removeEventListener('mousemove', handleRightMouseMove);
                document.removeEventListener('mouseup', handleRightMouseUp);
                
                if (directoryName) {
                    const projectData = loadProjectData(directoryName);
                    projectData.previewSidebarWidth = parseInt(rightSidebar.style.width, 10);
                    saveProjectData(directoryName, projectData);
                }
            };

            document.addEventListener('mousemove', handleRightMouseMove);
            document.addEventListener('mouseup', handleRightMouseUp);
        });

        function handleRightMouseMove(e) {
            const contentArea = document.getElementById('content-area');
            const newWidth = contentArea.getBoundingClientRect().right - e.clientX;
            if (newWidth > 100 && newWidth < 500) { // Min and max width
                rightSidebar.style.width = newWidth + 'px';
                if (sizeSelector.value !== 'list') {
                    isLayoutFrozen = false; // Force unfreeze before recalculating
                    layoutThumbnailsInGrid(); // Recalculate grid on resize
                }
            }
        }

        function updatePreviewPanel(buttonData) {
            previewContainer.innerHTML = '';
            let thumbnailsToPreview = [];

            if (buttonData) {
                // If a button is provided, find all matching thumbnails across all canvases.
                const { path, fullButtonText, specialType } = buttonData;
                const isCategoryOnly = specialType === 'plusOne';
                const username = projectUsernameInput.value.trim() || 'username';
                const category = path[0];
                const prefix = `[${username}]_${category}`;

                for (const canvas of canvases.values()) {
                    canvas.thumbnails.forEach(thumb => {
                        const baseFilename = thumb.dataset.fileName.substring(0, thumb.dataset.fileName.lastIndexOf('.'));
                        const filenameWithoutNumber = baseFilename.replace(/\s*\(\d+\)$/, '').trim();
                        
                        let matches = false;
                        if (isCategoryOnly) {
                             matches = filenameWithoutNumber.startsWith(prefix);
                        } else {
                            const expectedFilenamePart = `${prefix} ${fullButtonText}`;
                            matches = filenameWithoutNumber.startsWith(expectedFilenamePart);
                        }

                        if (matches) {
                            thumbnailsToPreview.push(thumb);
                        }
                    });
                }
            } else if (selectedThumbnails.size > 0) {
                // If no button is provided, use the currently selected thumbnails.
                thumbnailsToPreview = Array.from(selectedThumbnails);
            }

            thumbnailsToPreview.sort((a, b) => a.dataset.fileName.localeCompare(b.dataset.fileName));

            thumbnailsToPreview.forEach(thumb => {
                const clone = thumb.cloneNode(true);
                clone.style.position = 'relative';
                clone.style.left = 'auto';
                clone.style.top = 'auto';
                clone.style.marginBottom = '5px';
                clone.classList.remove('selected'); // Clones shouldn't carry over selection state

                makeDraggable(clone);
                
                previewContainer.appendChild(clone);
            });
            
            // Apply the layout after the DOM has been updated
            requestAnimationFrame(() => {
                const currentPreviewSize = document.getElementById('preview-size-selector').value;
                layoutPreviewPane(currentPreviewSize);
            });
        }

        function layoutPreviewPane(size) {
            const container = document.getElementById('preview-container');
            if (!container) return;
            const wrappers = container.querySelectorAll('.thumbnail-wrapper');
            const projectData = loadProjectData(directoryName);
            const verticalPadding = Number(projectData.previewVerticalPadding) || 5;
            const padding = 5; // Horizontal padding remains 5

            // Clear any existing absolute positioning before recalculating
            wrappers.forEach(w => {
                w.style.position = 'relative';
                w.style.left = '';
                w.style.top = '';
            });

            if (size === 'list') {
                wrappers.forEach(wrapper => {
                    // Reset styles for list view
                    wrapper.style.position = 'relative';
                    wrapper.style.left = '';
                    wrapper.style.top = '';
                    wrapper.classList.add('list-view');
                    const thumb = wrapper.querySelector('.thumbnail');
                    if (thumb) {
                        thumb.style.width = '128px'; // Fixed size for list view
                        thumb.style.height = '72px';
                    }
                });
            } else {
                // GRID VIEW LOGIC
                wrappers.forEach(wrapper => {
                    wrapper.classList.remove('list-view');
                    // Reset/set styles for grid view display
                    const thumb = wrapper.querySelector('.thumbnail');
                    if (thumb) thumb.style.display = ''; // Reset to default display (inline)

                    const nameDiv = wrapper.querySelector('.thumbnail-name');
                    if (nameDiv) nameDiv.style.display = 'none';
                    
                    const canvasNamePlaceholder = wrapper.querySelector('.canvas-name-placeholder');
                    if (canvasNamePlaceholder) canvasNamePlaceholder.style.display = 'none';
                    const newFilenamePlaceholder = wrapper.querySelector('.new-filename-placeholder');
                    if (newFilenamePlaceholder) newFilenamePlaceholder.style.display = 'none';
                });

                const scale = parseFloat(size);
                const containerWidth = container.clientWidth;
                let xOffset = padding;
                let yOffset = verticalPadding;
                let maxRowHeight = 0;

                wrappers.forEach(wrapper => {
                    const thumb = wrapper.querySelector('.thumbnail');
                    const nameDiv = wrapper.querySelector('.thumbnail-name');

                    const originalWidth = parseFloat(thumb.dataset.originalWidth || 256);
                    const originalHeight = parseFloat(thumb.dataset.originalHeight || 144);
                    
                    const scaledWidth = originalWidth * scale;
                    const scaledHeight = originalHeight * scale;

                    let nameHeight = 0;
                    if (nameDiv) {
                        const originalDisplay = nameDiv.style.display;
                        nameDiv.style.display = 'block'; // Ensure it's visible for measurement
                        nameDiv.style.maxWidth = scaledWidth + 'px';
                        nameHeight = nameDiv.offsetHeight;
                        nameDiv.style.display = originalDisplay;
                    }

                    const wrapperHeight = scaledHeight + nameHeight;

                    if (xOffset + scaledWidth + padding > containerWidth && xOffset > padding) {
                        xOffset = padding;
                        yOffset += maxRowHeight + verticalPadding;
                        maxRowHeight = 0;
                    }
                    
                    wrapper.style.position = 'absolute';
                    wrapper.style.left = xOffset + 'px';
                    wrapper.style.top = yOffset + 'px';
                    thumb.style.width = scaledWidth + 'px';
                    thumb.style.height = scaledHeight + 'px';

                    if (wrapperHeight > maxRowHeight) {
                        maxRowHeight = wrapperHeight;
                    }
                    
                    xOffset += scaledWidth + padding;
                });
            }
        }
        
        const previewSizeSelector = document.getElementById('preview-size-selector');
        previewSizeSelector.addEventListener('change', (event) => {
            const newSize = event.target.value;
            layoutPreviewPane(newSize);
            if (directoryName) {
                const projectData = loadProjectData(directoryName);
                projectData.previewThumbnailSize = newSize;
                saveProjectData(directoryName, projectData);
            }
        });


        generateEditThumbnailsNewBtn.addEventListener('click', () => {
            const trackingFileName = 'processed_edit_mode_videos.txt';
            const script = [
                '@echo off',
                'setlocal enabledelayedexpansion',
                'cd /d "%~dp0"',
                'echo Generating edit thumbnails for new files...',
                'if not exist "Edit Thumbnails" mkdir "Edit Thumbnails"',
                `set "trackingFile=${trackingFileName}"`,
                'if not exist "!trackingFile!" ( echo. > "!trackingFile!" )',
                '',
                'for %%F in (*.mp4, *.avi, *.mov, *.mkv) do (',
                '    set "videoFile=%%F"',
                '    findstr /x /c:"!videoFile!" "!trackingFile!" >nul',
                '    if errorlevel 1 (',
                '        echo Processing new file: !videoFile!',
                '        set "baseName=%%~nF"',
                `        for /f "delims=" %%a in ('ffprobe -v error -show_entries format^=duration -of default^=noprint_wrappers^=1:nokey^=1 "!videoFile!"') do (`,
                '            set "duration_str=%%a"',
                '        )',
                '        for /f "delims=." %%a in ("!duration_str!") do set "duration_int=%%a"',
                '        if !duration_int! equ 0 set "duration_int=10"',
                '        set /a "interval = !duration_int! / 10"',
                '        if !interval! equ 0 set "interval=1"',
                '        for /l %%i in (1, 1, 10) do (',
                '            set /a "timestamp = (%%i - 1) * !interval!"',
                `            ffmpeg -ss !timestamp! -i "!videoFile!" -vframes 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" -y "Edit Thumbnails\\!baseName!_%%i.jpg" >nul 2>&1`,
                '            if errorlevel 1 (',
                '                echo Failed to generate thumbnail %%i for !videoFile!',
                '            )',
                '        )',
                '        echo !videoFile!>> "!trackingFile!"',
                '    )',
                ')',
                '',
                'echo Thumbnail generation for new files complete.',
                'pause'
            ].join('\r\n');

            editScriptModal.querySelector('h2').textContent = 'Generate Thumbnails for Edit Mode for New Files';
            document.getElementById('edit-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-edit-script-link').href = URL.createObjectURL(blob);
            document.getElementById('download-edit-script-link').download = 'generate_edit_thumbnails_new.bat';
            editScriptModal.style.display = 'block';
        });

        generateFolderThumbnailsBtn.addEventListener('click', () => {
            const script = [
                '@echo off',
                'echo This will delete and regenerate all thumbnails in the Thumbnails folder.',
                'pause',
                'if exist "Thumbnails" ( rmdir /S /Q "Thumbnails" )',
                'mkdir "Thumbnails"',
                ...allVideoFiles.map(file => {
                    const fileName = file.name;
                    const thumbnailName = fileName.substring(0, fileName.lastIndexOf('.')) + '.jpg';
                    return `ffmpeg -y -i "${fileName}" -ss 00:00:02.000 -frames:v 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" "Thumbnails\\${thumbnailName}" >nul 2>&1 || echo Failed to generate thumbnail for ${fileName}`;
                }),
                'echo.',
                'echo Thumbnail regeneration complete.',
                'pause'
            ].join('\r\n');
            
            batchScriptTextArea.value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
            downloadScriptLink.download = 'generate_folder_thumbnails.bat';
            scriptModal.style.display = 'block';
        });

        refreshThumbnailsBtn.addEventListener('click', () => {
            const script = [
                '@echo off',
                'setlocal enabledelayedexpansion',
                'cd /d "%~dp0"',
                'echo Refreshing thumbnails...',
                'set "videoFiles=video_files.tmp"',
                '> "!videoFiles!" (',
                ...allVideoFiles.map(file => `    echo ${file.name.substring(0, file.name.lastIndexOf('.'))}`),
                ')',
                '',
                'for %%f in ("Thumbnails\\*.jpg") do (',
                '    set "thumbName=%%~nf"',
                '    findstr /x /c:"!thumbName!" "!videoFiles!" >nul',
                '    if errorlevel 1 (',
                '        echo Deleting orphaned thumbnail: %%f',
                '        del "%%f"',
                '    )',
                ')',
                '',
                'del "!videoFiles!"',
                '',
                ...allVideoFiles.map(file => {
                    const fileName = file.name;
                    const thumbnailName = fileName.substring(0, fileName.lastIndexOf('.')) + '.jpg';
                    return `if not exist "Thumbnails\\${thumbnailName}" ( ffmpeg -y -i "${fileName}" -ss 00:00:02.000 -frames:v 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" "Thumbnails\\${thumbnailName}" >nul 2>&1 || echo Failed to generate thumbnail for ${fileName} )`;
                }),
                'echo.',
                'echo Thumbnail refresh complete.',
                'pause'
            ].join('\r\n');

            batchScriptTextArea.value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
            downloadScriptLink.download = 'refresh_thumbnails.bat';
            scriptModal.style.display = 'block';
        });

        document.getElementById('export-project-btn').addEventListener('click', () => {
            if (!directoryName) {
                alert('Please load a directory first.');
                return;
            }
            const projectData = loadProjectData(directoryName);
            const dataStr = JSON.stringify(projectData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${directoryName}-project.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('information-btn').addEventListener('click', async () => {
            if (!directoryName) {
                alert('Please load a directory first.');
                return;
            }

            let totalThumbnails = 0;
            for (const canvas of canvases.values()) {
                totalThumbnails += canvas.thumbnails.length;
            }

            let editModeFilesCount = 0;
            try {
                const editDirHandle = await currentDirHandle.getDirectoryHandle('Edit Thumbnails');
                const uniqueVideoNames = new Set();
                for await (const entry of editDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.match(/\.(jpe?g|png|gif|webp)$/i)) {
                        const videoName = entry.name.substring(0, entry.name.lastIndexOf('_'));
                        uniqueVideoNames.add(videoName);
                    }
                }
                editModeFilesCount = uniqueVideoNames.size;
            } catch (e) {
                // Edit Thumbnails directory doesn't exist, so the count is 0.
            }

            alert(
                `Information:\n\n` +
                `- Thumbnails Loaded: ${totalThumbnails}\n` +
                `- Files in Edit Mode: ${editModeFilesCount}`
            );
        });

        function getBaseName(fileName) {
            // First, try to match the pattern with a numerical suffix like " (1)"
            const baseNameMatch = fileName.match(/^(.*) \(\d+\)\.\w+$/);
            if (baseNameMatch && baseNameMatch[1]) {
                return baseNameMatch[1];
            }
            // If it doesn't match, just remove the extension as a fallback.
            const lastDotIndex = fileName.lastIndexOf('.');
            if (lastDotIndex > 0) {
                return fileName.substring(0, lastDotIndex);
            }
            return fileName; // Return the whole string if no extension found
        }

        document.getElementById('recalculate-suffix-btn').addEventListener('click', () => {
            if (!directoryName) {
                alert('Please load a directory first.');
                return;
            }

            const renamedCanvas = Array.from(canvases.values()).find(c => c.name === 'Renamed');
            if (!renamedCanvas || renamedCanvas.thumbnails.length === 0) {
                alert('The "Renamed" canvas is empty. Nothing to recalculate.');
                return;
            }

            const groupedByBase = new Map();
            renamedCanvas.thumbnails.forEach(thumb => {
                const baseName = getBaseName(thumb.dataset.fileName);
                if (!groupedByBase.has(baseName)) {
                    groupedByBase.set(baseName, []);
                }
                groupedByBase.get(baseName).push(thumb);
            });

            groupedByBase.forEach((thumbnails, baseName) => {
                // Sort to ensure a consistent renumbering order
                thumbnails.sort((a, b) => a.dataset.fileName.localeCompare(b.dataset.fileName));

                thumbnails.forEach((thumb, index) => {
                    const newSuffix = `(${index + 1})`;
                    const newFilename = `${baseName} ${newSuffix}.jpg`;

                    // Update all relevant places
                    thumb.dataset.fileName = newFilename;
                    thumb.querySelector('.thumbnail').dataset.fileName = newFilename;
                    const nameDiv = thumb.querySelector('.thumbnail-name');
                    if (nameDiv) nameDiv.textContent = newFilename;
                    const newFilenamePlaceholder = thumb.querySelector('.new-filename-placeholder');
                    if (newFilenamePlaceholder) newFilenamePlaceholder.textContent = newFilename;
                });
            });

            saveCanvasState();
            renderCanvas(renamedCanvas.id); // Re-render to show changes
            alert('Suffixes in the "Renamed" canvas have been recalculated and compacted.');
        });
        
        document.getElementById('import-project-btn').addEventListener('click', () => {
            if (!directoryName) {
                alert('Please load a directory first.');
                return;
            }
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    try {
                        const projectData = JSON.parse(readerEvent.target.result);
                        // We can add more validation here, e.g., checking version
                        saveProjectData(directoryName, projectData);
                        alert('Project data imported successfully! Reloading...');
                        location.reload();
                    } catch (err) {
                        alert('Failed to parse project file.');
                    }
                }
                reader.readAsText(file);
            }
            input.click();
        });

        window.onload = init;

        // --- Test hook for Playwright ---
        class MockFileHandle {
            constructor(name) {
                this.name = name;
                this.kind = 'file';
            }
            async getFile() {
                // Return a real 1x1 pixel GIF to ensure Image.onload fires.
                const base64Gif = 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                const byteCharacters = atob(base64Gif);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], {type: 'image/gif'});
                return new File([blob], this.name, { type: 'image/gif' });
            }
        }

        class MockDirectoryHandle {
            constructor(name, entries) {
                this.name = name;
                this.kind = 'directory';
                this._entries = entries; // A map of names to handles
            }

            async getDirectoryHandle(name) {
                const entry = this._entries.get(name);
                if (entry && entry.kind === 'directory') {
                    return entry;
                }
                throw new DOMException('NotFoundError');
            }

            async *values() {
                for (const value of this._entries.values()) {
                    yield value;
                }
            }
        }
        
        document.getElementById('test-hook-load-dir').addEventListener('click', async () => {
            console.log("Test hook for complete directory clicked");
            const rootThumbnailsDir = new MockDirectoryHandle('Thumbnails', new Map([
                ['video1.jpg', new MockFileHandle('video1.jpg')]
            ]));
            const landscapeThumbnailsDir = new MockDirectoryHandle('Thumbnails', new Map([
                ['video2.jpg', new MockFileHandle('video2.jpg')]
            ]));
            const landscapeDir = new MockDirectoryHandle('Landscape', new Map([
                ['video2.mp4', new MockFileHandle('video2.mp4')],
                ['Thumbnails', landscapeThumbnailsDir]
            ]));

            const rootDir = new MockDirectoryHandle('verification-complete', new Map([
                ['video1.mp4', new MockFileHandle('video1.mp4')],
                ['Thumbnails', rootThumbnailsDir],
                ['Landscape', landscapeDir]
            ]));
            
            try {
                await processDirectory(rootDir);
                 console.log("processDirectory for complete dir finished");
            } catch(e) {
                console.error("Error in test hook processDirectory:", e);
            }
        });

        // Test hook for missing edit thumbnails scenario
        document.querySelector('.top-bar').insertAdjacentHTML('beforeend', '<button id="test-hook-missing-edit-thumbs" style="display:none;">Test Hook Missing Edit Thumbs</button>');
        document.getElementById('test-hook-missing-edit-thumbs').addEventListener('click', async () => {
            const editThumbnailsDir = new MockDirectoryHandle('Edit Thumbnails', new Map()); // Empty edit thumbs
            const thumbnailsDir = new MockDirectoryHandle('Thumbnails', new Map([
                ['video1.jpg', new MockFileHandle('video1.jpg')]
            ]));

            const rootDir = new MockDirectoryHandle('verification-missing-thumbs', new Map([
                ['video1.mp4', new MockFileHandle('video1.mp4')],
                ['Thumbnails', thumbnailsDir],
                ['Edit Thumbnails', editThumbnailsDir]
            ]));

            try {
                await processDirectory(rootDir);
            } catch (e) {
                console.error("Error in missing-thumbs test hook:", e);
            }
        });

        // --- Test hook for the long filename truncation issue ---
        document.querySelector('.top-bar').insertAdjacentHTML('beforeend', '<button id="test-hook-long-filename" style="display:none;">Test Hook Long Filename</button>');
        document.getElementById('test-hook-long-filename').addEventListener('click', async () => {
            const longFilename = '[username]_Misc (Top) (Black Logo Sleeveless Crop 1) (Bedroom 1) (Multiple) (Landscape) (1).jpg';
            const originalFilename = 'b2 - 7554368673050365206.jpg';

            const thumbnailsDir = new MockDirectoryHandle('Thumbnails', new Map([
                [longFilename, new MockFileHandle(longFilename)]
            ]));

            const rootDir = new MockDirectoryHandle('verification-long-filename', new Map([
                [originalFilename.replace('.jpg', '.mp4'), new MockFileHandle(originalFilename.replace('.jpg', '.mp4'))],
                ['Thumbnails', thumbnailsDir]
            ]));

            try {
                // Manually create a single canvas with the problematic thumbnail
                canvases.clear();
                const wrapper = document.createElement('div');
                wrapper.classList.add('thumbnail-wrapper');
                wrapper.dataset.fileName = longFilename;
                const nameDiv = document.createElement('div');
                nameDiv.classList.add('thumbnail-name');
                nameDiv.textContent = longFilename;
                nameDiv.dataset.originalFilename = originalFilename;
                wrapper.appendChild(nameDiv);
                 const newFilenameDiv = document.createElement('div');
                newFilenameDiv.classList.add('new-filename-placeholder');
                wrapper.appendChild(newFilenameDiv);
                const canvasNameDiv = document.createElement('div');
                canvasNameDiv.classList.add('canvas-name-placeholder');
                wrapper.appendChild(canvasNameDiv);


                canvases.set(1, { id: 1, name: 'Canvas 1', thumbnails: [wrapper], settings: { thumbnailSize: '1' } });
                activeCanvasId = 1;
                directoryName = 'verification-long-filename';

                renderCanvas(1);
            } catch(e) {
                console.error("Error in long-filename test hook:", e);
            }
        });
        
        document.getElementById('test-hook-load-padding-dir').addEventListener('click', async () => {
            console.log("Test hook for padding directory clicked");
            const thumbnailsDir = new MockDirectoryHandle('Thumbnails', new Map([
                ['video1.jpg', new MockFileHandle('video1.jpg')],
                ['video2.jpg', new MockFileHandle('video2.jpg')],
                ['video3.jpg', new MockFileHandle('video3.jpg')]
            ]));

            const rootDir = new MockDirectoryHandle('verification-padding', new Map([
                ['video1.mp4', new MockFileHandle('video1.mp4')],
                ['video2.mp4', new MockFileHandle('video2.mp4')],
                ['video3.mp4', new MockFileHandle('video3.mp4')],
                ['Thumbnails', thumbnailsDir]
            ]));

            try {
                await processDirectory(rootDir);
                 console.log("processDirectory for padding dir finished");
            } catch(e) {
                console.error("Error in test hook processDirectory:", e);
            }
        });

    </script>
</body>
</html>

